---
title: "CHILD CBMC and age one PBMC deconvolution"
author: "SL"
date: "2020-10-27"
output: html_document
---

*Purpose*: Cell type deconvolution allows prediction of cell type proportions in cordblood and PMBCs. Cell type proprotions are corrected for in later analysis. 

*NB*: For deconvolution using estimateCellCounts2 or estimateCellCounts must use RGset (estimateCellCounts2 allows mset but functionality is reduced). CHILD rgset_no_badsamp_probe_lowbead has bad samples removed. Bad probes, cross reactive probes, xy probes, and SNP probes have not yet been removed. 

Load required libraries
```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(sva)
library(minfi)
library(ExperimentHub)
library(FlowSorted.Blood.EPIC)
library(FlowSorted.CordBloodCombined.450k)
library(here)
```


Load rgset_no_badsamp_probe_lowbead for deconvolution comparison.  
```{r load_rgset}
load(here("output_data", "preprocessed_data", "2020-11-10_child_rgset_nobadsamp.Rdata"))
```


Separate cordblood (CMBCs) and year 1 PMBCs.
```{r separate_tissues}
#correct sample mix up 
#sample mix up was determined in preprocessing and analysis after rgset_no_badsamp_probe_lowbead was generated
#tissue mix up for sample 20113 -> relabel
rgset_nobadsamp$SampleID[5] <- "20113_P"
rgset_nobadsamp$Tissue[5] <- "P"
rgset_nobadsamp$SampleID[6] <- "20113_C"
rgset_nobadsamp$Tissue[6] <- "C"


#cord blood 
cb_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="C"]
dim(cb_rgset)

#year 1 pmbcs
y1_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="P"]
dim(y1_rgset)
```

Change estimateCellCounts2 and its internal function pickCompProbes to output probes used for deconvolution. Also have to re-initiate other internal functions for new version of estimateCellCOunts2 to work. 
```{r estimatecellcounts2_pickcompprobes}

#################
#pickCompProbes2#
#################

pickCompProbes2 <- 
  function(mSet, cellTypes = NULL, numProbes = 50, 
                            compositeCellType = compositeCellType, 
                            probeSelect = probeSelect) {
    p <- getBeta(mSet)
    pd <- as.data.frame(colData(mSet))
    if(!is.null(cellTypes)) {
        if(!all(cellTypes %in% pd$CellType))
            stop(strwrap("elements of argument 'cellTypes' are not part of 
                        'mSet$CellType'", width = 80, prefix = " ", 
                        initial = ""))
        keep <- which(pd$CellType %in% cellTypes)
        pd <- pd[keep,]
        p <- p[,keep]
    }
    ## make cell type a factor 
    pd$CellType <- factor(pd$CellType, levels = cellTypes)
    ffComp <- rowFtests(p, pd$CellType)
    tIndexes <- split(seq(along=pd$CellType), pd$CellType)
    prof <- vapply(tIndexes, function(i) rowMeans(p[,i]), 
                    FUN.VALUE=numeric(dim(p)[1]))
    r <- rowRanges(p)
    compTable <- cbind(ffComp, prof, r, abs(r[,1] - r[,2]))
    names(compTable)[1] <- "Fstat"
    names(compTable)[c(-2,-1,0) + ncol(compTable)] <- c("low", "high", "range") 
    tstatList <- lapply(tIndexes, function(i) {
        x <- rep(0,ncol(p))
        x[i] <- 1
        return(rowttests(p, factor(x)))
    })
    if (probeSelect == "any"){
        probeList <- lapply(tstatList, function(x) {
            y <- x[x[,"p.value"] < 1e-8,]
            yAny <- y[order(abs(y[,"dm"]), decreasing=TRUE),]      
            c(rownames(yAny)[seq_len(numProbes*2)])
        })
        #output all picked probes
        probelist_all <<- probeList
    } else {
        probeList <- lapply(tstatList, function(x) {
            y <- x[x[,"p.value"] < 1e-8,]
            yUp <- y[order(y[,"dm"], decreasing=TRUE),]
            yDown <- y[order(y[,"dm"], decreasing=FALSE),]
            c(rownames(yUp)[seq_len(numProbes)], 
                rownames(yDown)[seq_len(numProbes)])
        })
        #output all picked probes
        probelist_all <<- probeList
    }
    trainingProbes <- unique(unlist(probeList))
    p <- p[trainingProbes,]
    
    pMeans <- colMeans(p)
    names(pMeans) <- pd$CellType
    form <- as.formula(sprintf("y ~ %s - 1", paste(levels(pd$CellType), 
                                                    collapse="+")))
    phenoDF <- as.data.frame(model.matrix(~pd$CellType-1))
    colnames(phenoDF) <- sub("^pd\\$CellType", "", colnames(phenoDF))
    if(ncol(phenoDF) == 2) { # two group solution
        X <- as.matrix(phenoDF)
        coefEsts <- t(solve(t(X) %*% X) %*% t(X) %*% t(p))
    } else { # > 2 group solution
        tmp <- validationCellType(Y = p, pheno = phenoDF, modelFix = form)
        coefEsts <- tmp$coefEsts
    }
    
    out <- list(coefEsts = coefEsts, compTable = compTable,
                sampleMeans = pMeans)
    return(out)
}

###########################
#estimateCellCounts2Probes#
###########################

estimateCellCounts2probes <- 
function (rgSet, compositeCellType = "Blood", processMethod = "preprocessNoob", 
    probeSelect = c("auto", "any", "IDOL"), 
    cellTypes = c("CD8T", "CD4T", "NK", "Bcell", 
        "Mono", "Neu"), referencePlatform = c("IlluminaHumanMethylation450k", 
        "IlluminaHumanMethylationEPIC", "IlluminaHumanMethylation27k"), 
    referenceset = NULL, IDOLOptimizedCpGs = NULL, returnAll = FALSE, 
    meanPlot = FALSE, verbose = TRUE, lessThanOne = FALSE, ...) 
{
    if ((!is(rgSet, "RGChannelSet")) && (!is(rgSet, "MethylSet"))) 
        stop(strwrap(sprintf("object is of class '%s', but needs to be of \n                                class 'RGChannelSet' 'RGChannelSetExtended' or \n                                'MethylSet' to use this function", 
            class(rgSet)), width = 80, prefix = " ", initial = ""))
    if (!is(rgSet, "RGChannelSet") && (processMethod[1] != 
        "preprocessQuantile")) 
        stop(strwrap(sprintf("object is of class '%s', but needs to be of \n                                class 'RGChannelSet' or 'RGChannelSetExtended' \n                                to use other methods different to \n                                'preprocessQuantile'", 
            class(rgSet)), width = 80, prefix = " ", initial = ""))
    if (is(rgSet, "MethylSet") && (processMethod[1] == 
        "preprocessQuantile")) 
        message(strwrap("[estimateCellCounts2] The function will assume that\n                            no preprocessing has been performed. Using \n                            'preprocessQuantile' in prenormalized data is \n                            experimental and it should only be run under the \n                            user responsibility", 
            width = 80, prefix = " ", initial = ""))
    if (is(rgSet, "RGChannelSetExtended")) 
        rgSet <- as(rgSet, "RGChannelSet")
    referencePlatform <- match.arg(referencePlatform)
    rgPlatform <- sub("IlluminaHumanMethylation", "", 
        annotation(rgSet)[which(names(annotation(rgSet)) == "array")])
    platform <- sub("IlluminaHumanMethylation", "", 
        referencePlatform)
    if ((compositeCellType == "CordBlood" | compositeCellType == 
        "CordBloodCombined") && (!"nRBC" %in% cellTypes)) 
        message(strwrap("[estimateCellCounts2] Consider including 'nRBC' in \n                        argument 'cellTypes' for cord blood estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if ((compositeCellType == "Blood") && (referencePlatform == 
        "IlluminaHumanMethylationEPIC") && ("Gran" %in% 
        cellTypes)) 
        message(strwrap("[estimateCellCounts2] Replace 'Gran' for 'Neu' in \n                        argument 'cellTypes' for EPIC blood estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if ((compositeCellType != "Blood") && ("Neu" %in% 
        cellTypes)) 
        message(strwrap("[estimateCellCounts2] Check whether 'Gran' or 'Neu' is \n                        present in your reference and adjust argument \n                        'cellTypes' for your estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if (compositeCellType == "CordBloodCombined") 
        platform <= "450k"
    referencePkg <- sprintf("FlowSorted.%s.%s", compositeCellType, 
        platform)
    subverbose <- max(as.integer(verbose) - 1L, 0L)
    if (!is.null(referenceset)) {
        referenceRGset <- get(referenceset)
        if (!is(rgSet, "RGChannelSet")) 
            referenceRGset <- preprocessRaw(referenceRGset)
    }
    else {
        if (!require(referencePkg, character.only = TRUE)) 
            stop(strwrap(sprintf("Could not find reference data package for \n                                compositeCellType '%s' and referencePlatform \n                                '%s' (inferred package name is '%s')", 
                compositeCellType, platform, referencePkg), width = 80, 
                prefix = " ", initial = ""))
        if ((referencePkg != "FlowSorted.Blood.EPIC") && 
            (referencePkg != "FlowSorted.CordBloodCombined.450k")) {
            referenceRGset <- get(referencePkg)
        }
        else if (referencePkg == "FlowSorted.Blood.EPIC") {
            hub <- ExperimentHub()
            referenceRGset <- hub[["EH1136"]]
        }
        else if (referencePkg == "FlowSorted.CordBloodCombined.450k") {
            hub <- ExperimentHub()
            referenceRGset <- hub[["EH2256"]]
        }
        if (!is(rgSet, "RGChannelSet")) 
            referenceRGset <- preprocessRaw(referenceRGset)
    }
    if (rgPlatform != platform) {
        rgSet <- convertArray(rgSet, outType = referencePlatform, 
            verbose = TRUE)
    }
    if (!"CellType" %in% names(colData(referenceRGset))) 
        stop(strwrap(sprintf("the reference sorted dataset (in this case '%s') \n                            needs to have a phenoData column called \n                            'CellType'"), 
            names(referencePkg), width = 80, prefix = " ", 
            initial = ""))
    if (sum(colnames(rgSet) %in% colnames(referenceRGset)) > 
        0) 
        stop(strwrap("the sample/column names in the user set must not be in \n                    the reference data ", 
            width = 80, prefix = " ", initial = ""))
    if (!all(cellTypes %in% referenceRGset$CellType)) 
        stop(strwrap(sprintf("all elements of argument 'cellTypes' needs to be \n                            part of the reference phenoData columns 'CellType' \n                            (containg the following elements: '%s')", 
            paste(unique(referenceRGset$cellType), collapse = "', '")), 
            width = 80, prefix = " ", initial = ""))
    if (length(unique(cellTypes)) < 2) 
        stop("At least 2 cell types must be provided.")
    if ((processMethod == "auto") && (compositeCellType %in% 
        c("Blood", "DLPFC"))) 
        processMethod <- "preprocessQuantile"
    if ((processMethod == "auto") && (!compositeCellType %in% 
        c("Blood", "DLPFC")) && (is(rgSet, "RGChannelSet"))) 
        processMethod <- "preprocessNoob"
    processMethod <- get(processMethod)
    if ((probeSelect == "auto") && (compositeCellType %in% 
        c("CordBloodCombined", "CordBlood", "CordBloodNorway", 
            "CordTissueAndBlood"))) {
        probeSelect <- "any"
    }
    if ((probeSelect == "auto") && (!compositeCellType %in% 
        c("CordBloodCombined", "CordBlood", "CordBloodNorway", 
            "CordTissueAndBlood"))) {
        probeSelect <- "both"
    }
    if (verbose) 
        message(strwrap("[estimateCellCounts2] Combining user data with \n                        reference (flow sorted) data.\n", 
            width = 80, prefix = " ", initial = ""))
    newpd <- DataFrame(sampleNames = c(colnames(rgSet), colnames(referenceRGset)), 
        studyIndex = rep(c("user", "reference"), 
            times = c(ncol(rgSet), ncol(referenceRGset))))
    referenceRGset$CellType <- as.character(referenceRGset$CellType)
    if (is.null(rgSet$CellType)) 
        rgSet$CellType <- rep("NA", dim(rgSet)[2])
    if (is.null(rgSet$Age)) 
        rgSet$Age <- rep("NA", dim(rgSet)[2])
    if (is.null(rgSet$Sex)) 
        rgSet$Sex <- rep("NA", dim(rgSet)[2])
    if (is.null(referenceRGset$Sex)) {
        referenceRGset$Sex <- rep("NA", dim(referenceRGset)[2])
    }
    else {
        referenceRGset$Sex <- as.character(referenceRGset$Sex)
    }
    if (is.null(referenceRGset$Age)) {
        referenceRGset$Age <- rep("NA", dim(referenceRGset)[2])
    }
    else {
        try(referenceRGset$Age <- as.numeric(referenceRGset$Age))
    }
    commoncolumn <- intersect(names(colData(rgSet)), names(colData(referenceRGset)))
    restry <- try({
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }, silent = TRUE)
    if ("try-error" %in% class(restry)) {
        commoncolumn <- c("CellType", "Sex", "Age")
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }
    else {
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }
    rm(restry)
    colData(referenceRGset) <- colData(referenceRGset)[commoncolumn]
    colData(rgSet) <- colData(rgSet)[commoncolumn]
    referencePd <- colData(referenceRGset)
    combinedRGset <- combineArrays(rgSet, referenceRGset, outType = referencePlatform)
    colData(combinedRGset) <- newpd
    colnames(combinedRGset) <- newpd$sampleNames
    rm(referenceRGset)
    if (verbose) 
        message(strwrap("[estimateCellCounts2] Processing user and reference \n                        data together.\n", 
            width = 80, prefix = " ", initial = ""))
    if (compositeCellType == "CordBlood") {
        if (!is(combinedRGset, "RGChannelSet")) 
            combinedRGset@preprocessMethod["rg.norm"] <- "Raw (no normalization or bg correction)"
        combinedMset <- processMethod(combinedRGset, verbose = subverbose)
        rm(combinedRGset)
        gc()
        compTable <- get(paste0(referencePkg, ".compTable"))
        combinedMset <- combinedMset[which(rownames(combinedMset) %in% 
            rownames(compTable)), ]
    }
    else {
        if (!is(combinedRGset, "RGChannelSet")) 
            combinedRGset@preprocessMethod["rg.norm"] <- "Raw (no normalization or bg correction)"
        combinedMset <- processMethod(combinedRGset)
        rm(combinedRGset)
        gc()
    }
    referenceMset <- combinedMset[, combinedMset$studyIndex == 
        "reference"]
    colData(referenceMset) <- as(referencePd, "DataFrame")
    mSet <- combinedMset[, combinedMset$studyIndex == "user"]
    colData(mSet) <- as(colData(rgSet), "DataFrame")
    rm(combinedMset)
    if (probeSelect != "IDOL") {
        if (verbose) 
            message(strwrap("[estimateCellCounts2] Picking probes for \n                            composition estimation.\n", 
                width = 80, prefix = " ", initial = ""))
        compData <- pickCompProbes2(referenceMset, cellTypes = cellTypes, 
            compositeCellType = compositeCellType, probeSelect = probeSelect)
        #output all probes 
        compData <<- compData
        coefs <- compData$coefEsts
        if (verbose) 
            message("[estimateCellCounts2] Estimating composition.\n")
        counts <- projectCellType(getBeta(mSet)[rownames(coefs), 
            ], coefs, lessThanOne = lessThanOne)
        rownames(counts) <- colnames(rgSet)
        if (meanPlot) {
            smeans <- compData$sampleMeans
            smeans <- smeans[order(names(smeans))]
            sampleMeans <- c(colMeans(minfi::getBeta(mSet)[rownames(coefs), 
                ]), smeans)
            sampleColors <- c(rep(1, ncol(mSet)), 1 + as.numeric(factor(names(smeans))))
            plot(sampleMeans, pch = 21, bg = sampleColors)
            legend("bottomleft", c("blood", levels(factor(names(smeans)))), 
                col = seq_len(7), pch = 15)
        }
        if (returnAll) {
            list(counts = counts, compTable = compData$compTable, 
                normalizedData = mSet)
        }
        else {
            list(counts = counts)
        }
    }
    else {
        if (verbose) 
            message(strwrap("[estimateCellCounts2] Using IDOL L-DMR probes for \n                            composition estimation.\n", 
                width = 80, prefix = " ", initial = ""))
        p <- getBeta(referenceMset)
        pd <- as.data.frame(colData(referenceMset))
        rm(referenceMset)
        if (!is.null(cellTypes)) {
            if (!all(cellTypes %in% pd$CellType)) 
                stop(strwrap("elements of argument 'cellTypes' is not part of \n                            'referenceMset$CellType'", 
                  width = 80, prefix = " ", initial = ""))
            keep <- which(pd$CellType %in% cellTypes)
            pd <- pd[keep, ]
            p <- p[, keep]
        }
        pd$CellType <- factor(pd$CellType, levels = cellTypes)
        ffComp <- rowFtests(p, pd$CellType)
        tIndexes <- split(seq(along = pd$CellType), pd$CellType)
        prof <- vapply(tIndexes, function(i) rowMeans(p[, i]), 
            FUN.VALUE = numeric(dim(p)[1]))
        r <- rowRanges(p)
        compTable <- cbind(ffComp, prof, r, abs(r[, 1] - r[, 
            2]))
        names(compTable)[1] <- "Fstat"
        names(compTable)[c(-2, -1, 0) + ncol(compTable)] <- c("low", 
            "high", "range")
        tstatList <- lapply(tIndexes, function(i) {
            x <- rep(0, ncol(p))
            x[i] <- 1
            return(rowttests(p, factor(x)))
        })
        trainingProbes <- IDOLOptimizedCpGs
        trainingProbes <- trainingProbes[trainingProbes %in% 
            rownames(p)]
        p <- p[trainingProbes, ]
        pMeans <- colMeans(p)
        names(pMeans) <- pd$CellType
        form <- as.formula(sprintf("y ~ %s - 1", paste(levels(pd$CellType), 
            collapse = "+")))
        phenoDF <- as.data.frame(model.matrix(~pd$CellType - 
            1))
        colnames(phenoDF) <- sub("^pd\\$CellType", "", 
            colnames(phenoDF))
        if (ncol(phenoDF) == 2) {
            X <- as.matrix(phenoDF)
            coefEsts <- t(solve(t(X) %*% X) %*% t(X) %*% t(p))
            coefs <- coefEsts
        }
        else {
            tmp <- validationCellType(Y = p, pheno = phenoDF, 
                modelFix = form)
            coefEsts <- tmp$coefEsts
            coefs <- coefEsts
        }
        compData <- list(coefEsts = coefEsts, compTable = compTable, 
            sampleMeans = pMeans)
        if (verbose) 
            message("[estimateCellCounts2] Estimating composition.\n")
        counts <- projectCellType(getBeta(mSet)[rownames(coefs), 
            ], coefs, lessThanOne = lessThanOne)
        rownames(counts) <- colnames(rgSet)
        if (meanPlot) {
            smeans <- compData$sampleMeans
            smeans <- smeans[order(names(smeans))]
            sampleMeans <- c(colMeans(getBeta(mSet)[rownames(coefs), 
                ]), smeans)
            sampleColors <- c(rep(1, ncol(mSet)), 1 + as.numeric(factor(names(smeans))))
            plot(sampleMeans, pch = 21, bg = sampleColors)
            legend("bottomleft", c("blood", levels(factor(names(smeans)))), 
                col = seq_len(7), pch = 15)
        }
        if (returnAll) {
            list(counts = counts, compTable = compTable, normalizedData = mSet)
        }
        else {
            list(counts = counts)
        }
    }
}


#################
#projectCellType#
#################
projectCellType <- 
  function(Y, coefCellType, contrastCellType=NULL, 
                    nonnegative=TRUE, lessThanOne=lessThanOne){ 
    if(is.null(contrastCellType))
        Xmat <- coefCellType
    else
        Xmat <- tcrossprod(coefCellType, contrastCellType) 
    nCol <- dim(Xmat)[2]
    if(nCol == 2) {
        Dmat <- crossprod(Xmat)
        mixCoef <- t(apply(Y, 2, function(x) {solve(Dmat, crossprod(Xmat, x))}))
        colnames(mixCoef) <- colnames(Xmat)
        return(mixCoef)
    } else {
        nSubj <- dim(Y)[2]
        mixCoef <- matrix(0, nSubj, nCol)
        rownames(mixCoef) <- colnames(Y)
        colnames(mixCoef) <- colnames(Xmat)
        if(nonnegative){
            if(lessThanOne) {
                Amat <- cbind(rep(-1, nCol), diag(nCol))
                b0vec <- c(-1, rep(0, nCol))
            } else {
                Amat <- diag(nCol)
                b0vec <- rep(0, nCol)
            }
            for(i in seq_len(nSubj)) {
                obs <- which(!is.na(Y[,i])) 
                Dmat <- crossprod(Xmat[obs,])
                mixCoef[i,] <- solve.QP(Dmat, crossprod(Xmat[obs,], Y[obs,i]), 
                                        Amat, b0vec)$sol
            }
        } else {
            for(i in seq_len(nSubj)) {
                obs <- which(!is.na(Y[,i])) 
                Dmat <- crossprod(Xmat[obs,])
                mixCoef[i,] <- solve(Dmat, t(Xmat[obs,]) %*% Y[obs,i])
            }
        }
        return(mixCoef)
    }
}



####################
#validationCellType#
####################

validationCellType <- 
  function(Y, pheno, modelFix, modelBatch=NULL,
                                L.forFstat = NULL, verbose = FALSE){
    N <- dim(pheno)[1]
    pheno$y <- rep(0, N)
    xTest <- model.matrix(modelFix, pheno)
    sizeModel <- dim(xTest)[2]
    M <- dim(Y)[1]
    if(is.null(L.forFstat)) {
        L.forFstat <- diag(sizeModel)[-1,] # All non-intercept coefficients
        colnames(L.forFstat) <- colnames(xTest) 
        rownames(L.forFstat) <- colnames(xTest)[-1] 
    }
    # Initialize various containers
    sigmaResid <- sigmaIcept <- nObserved <- nClusters <- Fstat <- rep(NA, M)
    coefEsts <- matrix(NA, M, sizeModel)
    coefVcovs <- list()
    if(verbose)
        cat("[validationCellType] ")
    for(j in seq_len(M)) { # For each CpG
        ## Remove missing methylation values
        ii <- !is.na(Y[j,])
        nObserved[j] <- sum(ii)
        pheno$y <- Y[j,]

        if(j%%round(M/10)==0 && verbose)
            cat(".") # Report progress
        
        try({ # Try to fit a mixed model to adjust for plate
            if(!is.null(modelBatch)) {
                fit <- try(lme(modelFix, random=modelBatch, data=pheno[ii,]))
                OLS <- inherits(fit,"try-error") 
                # If LME can't be fit, just use OLS
            } else
                OLS <- TRUE
            
            if(OLS) {
                fit <- lm(modelFix, data=pheno[ii,])
                fitCoef <- fit$coef
                sigmaResid[j] <- summary(fit)$sigma
                sigmaIcept[j] <- 0
                nClusters[j] <- 0
            } else { 
                fitCoef <- fit$coef$fixed
                sigmaResid[j] <- fit$sigma
                sigmaIcept[j] <- sqrt(getVarCov(fit)[1])
                nClusters[j] <- length(fit$coef$random[[1]])
            }
            coefEsts[j,] <- fitCoef
            coefVcovs[[j]] <- vcov(fit)
            
            useCoef <- L.forFstat %*% fitCoef
            useV <- L.forFstat %*% coefVcovs[[j]] %*% t(L.forFstat)
            Fstat[j] <- (t(useCoef) %*% solve(useV, useCoef))/sizeModel
        })
    }
    if(verbose)
        cat(" done\n")
    ## Name the rows so that they can be easily matched to the target data set
    rownames(coefEsts) <- rownames(Y)
    colnames(coefEsts) <- names(fitCoef)
    degFree <- nObserved - nClusters - sizeModel + 1
    
    ## Get P values corresponding to F statistics
    Pval <- 1-pf(Fstat, sizeModel, degFree)
    
    out <- list(coefEsts=coefEsts, coefVcovs=coefVcovs, modelFix=modelFix, 
                modelBatch=modelBatch,
                sigmaIcept=sigmaIcept, sigmaResid=sigmaResid, 
                L.forFstat=L.forFstat, Pval=Pval,
                orderFstat=order(-Fstat), Fstat=Fstat, nClusters=nClusters, 
                nObserved=nObserved,
                degFree=degFree)
    
    out
}

```



Deconvolution of CBMCs (cord blood) and year 1 PBMCs using cordblood reference sets using estimateCellCounts2 and FlowSorted.CordBloodCombined.450k 
```{r child_fscbc_ecc2}
hub <- ExperimentHub()
myfiles <- query(hub, "FlowSorted.CordBloodCombined.450k")
FlowSorted.CordBloodCombined.450k <- myfiles[[1]]
FlowSorted.CordBloodCombined.450k



#CBMCs (cordblood) with cord blood reference set 
#dont include granulocytes since they are not expected in CBMCs
child_fscbc_ecc2_cb <- estimateCellCounts2probes(cb_rgset, 
                            compositeCellType = "CordBlood",
                            processMethod = "preprocessNoob",
                            cellTypes = c("CD4T","NK","nRBC","Bcell","Mono","CD8T"), 
                            referencePlatform = "IlluminaHumanMethylation450k",
                            referenceset = "FlowSorted.CordBloodCombined.450k",
                            returnAll = FALSE) 

# add in line for renaming outputted probes

#year 1 PBMCs with cordblood reference set
#dont include granulocytes or nRBCs since neither are expected in year 1 PBMCs
child_fscbc_ecc2_y1 <- estimateCellCounts2probes(y1_rgset, 
                            compositeCellType = "CordBlood",
                            processMethod = "preprocessNoob",
                            cellTypes = c("CD4T","NK", "Bcell","Mono","CD8T"), 
                            referencePlatform = "IlluminaHumanMethylation450k",
                            referenceset = "FlowSorted.CordBloodCombined.450k",
                            returnAll = FALSE) 
```



Save deconvoluted data.    
```{r deconvo_data}
save(child_fscbc_ecc2_cb, child_fscbc_ecc2_y1, 
     cb_allprobes, cb_deconvolutionprobes,
     y1_allprobes, y1_deconvolutionprobes,
     file=here("output_data","deconvolution", "2021-01-07_CBMC_PBMC_deconvolution.Rdata"))
```

