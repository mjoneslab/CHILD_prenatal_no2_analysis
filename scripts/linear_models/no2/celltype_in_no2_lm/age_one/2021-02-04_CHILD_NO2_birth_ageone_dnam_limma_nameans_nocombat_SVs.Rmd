---
title: "Age one linear regression using limma with complete cases"
author: "SL"
date: "12/09/2020"
output: html_document
---

*Purpose*: The purpose of this script is to DNAm changes in year one PBMCs associated with year one air pollution exposure (proxied by no2). This script uses a subtraction method to "cancel" out effects of prenatal exposure, allowing the investigation of year one specific changes. 


Load required libraries.
```{r libraries}
library(tidyverse)
library(limma)
library(here)
library(pbapply)
library(piecewiseSEM)
```

Run linear regression with technical factors in linear model (vs using combat to correct for them)

Load  betas data
```{r covariates}
load(file=here("output_data", "preprocessed_data",
               "2021-01-14_CHILD_preprocessed_betas_pdata_annotation.Rdata"))
```

Load covariate data
```{r covariates}
load(file=here("output_data", "covariates", "2020-11-12_CHILD_covariates_na_with_means.Rdata"))

#subset out cord blood and year one pData
#cord blood pdata
cb_pdata <- subset(pdata_nodups, Tissue == "C")
dim(cb_pdata) # 144  17

#year one pdatga
y1_pdata <- subset(pdata_nodups, Tissue == "P")
dim(y1_pdata) # 145  17

#year one data has one individual that is missing birth data
#remove this individual
y1_pdata_sub <- y1_pdata[y1_pdata$Sample_Label %in% cb_pdata$Sample_Label, ]
dim(y1_pdata_sub) # 144  17
```


Subset out cord blood and age one betas
```{r sub_betas}
#subset pData into CBMCs (cord blood)
#these children have data at both time points
cb_betas <- betas[,colnames(betas) %in% rownames(cb_pdata)]
#check size of cord blood data
dim(cb_betas) # 424644    144
min(cb_betas) # 0.002973941
max(cb_betas) # 0.9980669

#check if cord blood DNAm samples are in same order in cord blood pdata
identical(colnames(cb_betas), rownames(cb_pdata)) #true
#rename columns of cb_betas
colnames(cb_betas) <- cb_pdata$Sample_Label


#subset out cordblood samples from beta matrix
y1_betas <- betas[,colnames(betas) %in% rownames(y1_pdata_sub)]
#check size of year one data
dim(y1_betas) # 424644    144
min(y1_betas) #0.002650193
max(y1_betas) #0.9983506

#check if cord blood DNAm samples are in same order in cord blood pdata
identical(colnames(y1_betas), rownames(y1_pdata_sub)) #true
#rename columns of cb_betas
colnames(y1_betas) <- y1_pdata_sub$Sample_Label

#check if cord blood samples and year one samples are in same order
identical(colnames(cb_betas), colnames(y1_betas))
```


Subtract cord blood DNAm data from year one DNAm data. 
```{r diff_betas}
#check if cord blood samples and year one samples are in same order
identical(colnames(cb_betas), colnames(y1_betas))

#subtract cord blood DNAm from year one DNAm ("difference betas")
diff_betas <- y1_betas - cb_betas
#check size of difference betas
dim(diff_betas) # 424644    144
min(diff_betas) # -0.9793121 
max(diff_betas) # 0.9797916
```

Subset covariates and pdata for samples in diff_betas
```{r sub_covariates_pdata}
#subset covariates
covariates_sub <- 
  covariates_nameans[as.character(covariates_nameans$sampleid) %in% colnames(diff_betas), ]

#check order
identical(as.character(covariates_sub$sampleid), colnames(diff_betas)) #true
dim(covariates_sub) #144

#check order
identical(as.character(cb_pdata$Sample_Label), colnames(diff_betas)) #true
dim(cb_pdata) #144

#check order
identical(as.character(y1_pdata_sub$Sample_Label), colnames(diff_betas)) #true
dim(y1_pdata_sub) #144
```

Load combined cell type PCs (CBMC and PBMC together).
```{r load_celltype_PCs}
load(here("output_data", "deconvolution", "2021-02-04_CHILD_CBMC_PBMC_PCs.Rdata"))

#check size
dim(ccc_pcs) #144 11

#rename columns for clarity
colnames(ccc_pcs) <- paste("celltype.", colnames(ccc_pcs), sep="")

#check that cell type pcs and covariates are in the same order
identical(as.character(covariates_sub$sampleid), rownames(ccc_pcs)) #true

#combine cell type pcs and covariates
covariates_ctpcs <- cbind(covariates_sub, ccc_pcs)
dim(covariates_ctpcs)
```


Load genotyping PCs and subset out REEGLE PCs (genotyping data contains PCs for a few thousand participants).
```{r genotypingPCS}
genotyping <- read.csv(here("input_data", "genotyping", "CHILD_subjects_Qced_first10PCS_Duan.csv"))
  
#make rownames sample names then rmove this row
rownames(genotyping) <- genotyping$FID
genotyping <- subset(genotyping, select=-c(FID, IID))

genosub <- genotyping[rownames(genotyping) %in% cb_pdata$Sample_Label,]
#missing genotyping data for 14 REEGLE children?

#rename columns of genotyping data for clarity
colnames(genosub) <- paste("genotyping.", colnames(genosub), sep="")

#put rows in numerical order according to sample id
genosub_order <- genosub[order(rownames(genosub)), ]
```


Subset covariates, betas, cb_pdata, and y1_pdata for samples that also have genotyping.
```{r sub_on_geno}
#subset cb_pdata
cb_pdata_geno <- cb_pdata[as.character(cb_pdata$Sample_Label) %in% rownames(genosub_order), ]
#check size
dim(cb_pdata_geno) #131
#check order
identical(as.character(cb_pdata_geno$Sample_Label), rownames(genosub_order)) #true

#subset y1_pdata
y1_pdata_geno <- y1_pdata_sub[as.character(y1_pdata_sub$Sample_Label) %in% rownames(genosub_order), ]
#check size
dim(y1_pdata_geno) #131
#check order
identical(as.character(y1_pdata_geno$Sample_Label), rownames(genosub_order)) #true

#subset covariates
covariates_ctpcs_geno <- covariates_ctpcs[as.character(covariates_ctpcs$sampleid) %in% rownames(genosub_order), ]
#check size
dim(covariates_ctpcs_geno) #131
#check order
identical(as.character(covariates_ctpcs_geno$sampleid), rownames(genosub_order)) #true

#combine covariates with genotyping data
covariates_ctpcs_geno <- cbind(covariates_ctpcs_geno, genosub_order)

#subset betas
diff_betas_geno <- diff_betas[,colnames(diff_betas) %in% rownames(genosub_order)]
#check size
dim(diff_betas_geno) #131
#check order
identical(colnames(diff_betas_geno), rownames(genosub_order)) #true

#### add row run and chip to covariates

#check that covariates and dpata are in same order
identical(as.character(cb_pdata_geno$Sample_Label), 
          as.character(covariates_ctpcs_geno$sampleid)) #true

#create new column for technical variables in y1 pdata
y1_pdata_geno$y1_chip <- as.factor(y1_pdata_geno$Sentrix_ID)
y1_pdata_geno$y1_run <- as.factor(y1_pdata_geno$Run)
y1_pdata_geno$y1_row <- as.numeric(as.factor(substr(y1_pdata_geno$Sentrix_Position, 1, 3)))

y1_pdata_geno$cb_chip <- as.factor(cb_pdata_geno$Sentrix_ID)
y1_pdata_geno$cb_run <- as.factor(cb_pdata_geno$Run)
y1_pdata_geno$cb_row <- as.numeric(as.factor(substr(cb_pdata_geno$Sentrix_Position, 1, 3)))

#add technical columns of y1 pdata to covariates data
covariates_ctpcs_geno_tech <- cbind(covariates_ctpcs_geno, 
                                    y1_pdata_geno[,c("cb_run", "cb_row", "cb_chip",
                                                     "y1_run", "y1_row", "y1_chip")])
``` 



Linear regression using limma and complete cases
```{r limma}
#further subset covariates and beta values for complete cases
#subset covariates
covariates_ctpcs_geno_tech_cc <- 
  covariates_ctpcs_geno_tech[covariates_ctpcs_geno_tech %>% 
                             dplyr::select(no2_y1_entire, sex,  
                                           maternal_smoking_y1,  
                                           maternal_education_length, 
                                           pss_6mos,
                                           csed_6mos, 
                                           genotyping.PC1, 
                                           genotyping.PC2,
                                           genotyping.PC3,
                                           celltype.PC1, celltype.PC2,
                                           celltype.PC3, celltype.PC4,
                                           celltype.PC5, celltype.PC6,
                                           celltype.PC7, celltype.PC8,
                                           celltype.PC9
                                           #cb_run, cb_row, 
                                           #y1_row, y1_run
                                           ) %>% complete.cases,] 

#create model matrix
mod <- 
  model.matrix(~ no2_y1_entire + as.factor(sex) +
                 as.factor(maternal_smoking_y1) + 
                 maternal_education_length +
                 pss_6mos + 
                 csed_6mos + 
                 genotyping.PC1 + genotyping.PC2 + 
                 genotyping.PC3 + 
                 celltype.PC1 + celltype.PC2+
                 celltype.PC3+ celltype.PC4+
                 celltype.PC5+ celltype.PC6+
                 celltype.PC7+ celltype.PC8+
                 celltype.PC9 +  
               #as.character(cb_chip) + as.character(y1_chip) +
                 as.factor(cb_run) + as.factor(y1_run) + 
                 y1_row + cb_row  , 
               data=covariates_ctpcs_geno_tech_cc)

#check size
dim(mod) #125


#check size
dim(covariates_ctpcs_geno_tech_cc) # 125 140 

#subset betas
diff_betas_geno_cc <- 
  diff_betas_geno[,colnames(diff_betas_geno) %in% covariates_ctpcs_geno_tech_cc$sampleid]
#check size
dim(diff_betas_geno_cc) # 424644    125

#remove betas that were used for cell type prediction
diff_betas_geno_cc_cpr <- 
  diff_betas_geno_cc[!rownames(diff_betas_geno_cc) %in% rownames(cb_deconvolutionprobes$coefEsts) & !rownames(diff_betas_geno_cc) %in% rownames(y1_deconvolutionprobes$coefEsts), ]
#check size
dim(diff_betas_geno_cc_cpr) #424079    125
#565 probes removed

#################
# calculate svs #
#################

#null matrix

mod0 <- 
  model.matrix(~ 1, 
               data=covariates_ctpcs_geno_tech_cc)

#Set seed
set.seed(1234)
#Estimate the number of surrogate variables
 #if n.sv is not included, the number of factors is estimated for you
svobj = sva(diff_betas_geno_cc_cpr,mod,mod0) # 16 factors

# How much variance do the sv's account for
dat <- diff_betas_geno_cc_cpr
pprob <- svobj$pprob.gam*(1-svobj$pprob.b)
dats <- dat*pprob
dats <- dats - rowMeans(dats)
uu <- eigen(t(dats)%*%dats)
uu_val <- uu$values/sum(uu$values)
# Do I need to square these?
uu_val2 <- uu_val^2

x_val <- 1:ncol(dats)

expl_var_plot <- as.data.frame(cbind(x_val,uu_val2))

ggplot(expl_var_plot[1:15,], aes(x_val,uu_val2)) +
  geom_point(size=3,pch=19, color="blue")  + 
  scale_color_gradient() +  
  #geom_text(aes(label=rownames(expl_var_plot)),hjust=0.5,vjust=2,size=3) +
  xlab("SV") +
  ylab("uuvalues)")




covariates_ctpcs_geno_tech_cc <- cbind(covariates_ctpcs_geno_tech_cc,svobj$sv)
colnames(covariates_ctpcs_geno_tech_cc)[141:156] <- 
  c("sv1", "sv2", "sv3", "sv4", "sv5",
    "sv6", "sv7", "sv8", "sv9", "sv10",
    "sv11", "sv12", "sv13", "sv14", "sv15", "sv16")

mvals <- lumi::beta2m(diff_betas_geno_cc_cpr)


#pca 
uncor.dat <- t(scale(t(mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- covariates_ctpcs_geno_tech_cc[,c("sex", "cb_chip", "y1_chip",
                                                     "cb_run", "y1_run",
                                                    "maternal_smoking_y1")] 
meta_continuous <- covariates_ctpcs_geno_tech_cc[,c("no2_y1_entire", 
                                                   "genotyping.PC1",
                                                   "genotyping.PC2",
                                                   "genotyping.PC3",
                                                   "celltype.PC1", 
                                                   "celltype.PC2",
                                                   "celltype.PC3", 
                                                   "celltype.PC4",
                                                   "celltype.PC5",
                                                   "celltype.PC6",
                                                   "celltype.PC7",
                                                   "celltype.PC8",
                                                   "celltype.PC9",
                                                   "pss_6mos",
                                                   "csed_6mos",
                                                   "maternal_education_length",
                                                   "cb_row", "y1_row",
                                                   "sv1", "sv2", "sv3", "sv4",
                                                    "sv5", "sv6", "sv7", "sv8", 
                                                   "sv9", "sv10", "sv11", 
                                                   "sv12", "sv13", "sv14", 
                                                   "sv15", "sv16")]
# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:40)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)



#Design matrix for limma with surrogate variables
modSv = cbind(mod,svobj$sv[,1:15])


###############
#### LIMMA ####
###############

#fit methylation to no2
diff_fit <-  lmFit(diff_betas_geno_cc_cpr, mod)
diff_ebayes <- eBayes(diff_fit)

#add annotation to cb_ebayes
#pull annotation for cpgs contained in diff_betas
annotation_cpgs <- annotation[rownames(annotation) %in% rownames(diff_ebayes),]
#check order
identical(rownames(annotation_cpgs), rownames(diff_ebayes)) #false
#match
annotation_cpgs_order <- annotation_cpgs[rownames(diff_ebayes), ]
identical(rownames(annotation_cpgs_order), rownames(diff_ebayes)) #true

diff_ebayes$annotation <- annotation_cpgs_order

#pull out pval, coefficients and annotation
diff_pvals_tech <- cbind(as.data.frame(diff_ebayes$p.value), 
                  as.data.frame(diff_ebayes$coefficients),
                  as.data.frame(diff_ebayes$annotation))

#rename columns to indicate pvalues vs coefficients 
colnames(diff_pvals_tech) <- c(paste("pval", colnames(diff_pvals_tech)[1:27],
                                     sep = "_"), 
                               paste("coeff", colnames(diff_pvals_tech)[28:54], 
                                     sep = "_"),
                               colnames(diff_pvals_tech)[55:87])

diff_pvals_tech$adj_pval_no2_y1_entire <- p.adjust(diff_pvals_tech$pval_no2_y1_entire, method="BH")
```



Examine qqplot and pvalue histogram.
```{r qqplot_pval_histo}
########
#qqplot#
########

# use code from qqman::qq function 
# plot with ggplot to make it more aesthetically appealling 
pvector <- diff_pvals_tech$pval_no2_y1_entire

pvector2 <- pvector[!is.na(pvector) & !is.nan(pvector) & !is.null(pvector) & 
                      is.finite(pvector) & pvector < 1 & pvector > 0]

pval_qq <- as.data.frame(cbind(o = -log10(sort(pvector2, decreasing = FALSE)),
                               e = -log10(ppoints(length(pvector2)))))

#calculate lambda
chisq <- qchisq(1-pvector,1)
lambda <-  median(chisq)/qchisq(0.5,1)
 
ggplot(pval_qq, aes(x=e, y=o)) + 
  geom_point(col="#254A90", size=1) + 
  geom_abline(slope = 1, intercept = 0, col = "red", size=0.25) +
  labs(x = "Expected -log10(p-value)",
       y = "Observed -log10(p-value)") +
  annotate("text", x=4, y=1, label = paste("λ = ", round(lambda, 2)), size=3) +
  scale_x_continuous(breaks=c(0,2,4,6),
                     labels=c("-0.00", "-2.00", "-4.00", "-6.00")) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size=5,angle=90, vjust = 0.5, hjust=1),
        axis.text.y = element_text(size=5),
        axis.title.x = element_text(size=7),
        axis.title.y = element_text(size=7)) +
    ggsave( filename="2021-02-04_CHILD_y1_qqplot.tiff",
          device = "tiff",
          path =  here("figures", "linear_regression"),
          width = 2,
          height = 2,
          units = "in",
          limitsize = TRUE)
###########
#histogram#
###########

ggplot(data = diff_pvals_tech, aes(x=pval_no2_y1_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20))
```


Delta beta
```{r db}
range = max(covariates_ctpcs_geno_tech_cc$no2_y1_entire) -
    min(covariates_ctpcs_geno_tech_cc$no2_y1_entire)

diff_pvals_tech$db <- diff_pvals_tech$coeff_no2_y1_entire * range
```



Volcano plot
```{r volcano_db_tech}
#make new column to label sig points with cpgid
diff_pvals_tech$cpgid <- rownames(diff_pvals_tech)

#volcano plot
ggplot(diff_pvals_tech, aes(x=as.numeric(db)*100 , y=-log10(as.numeric(pval_no2_y1_entire)))) +
  geom_point(alpha=0.4, col = "#508FC2", size=3) +
  
  #nominal p value cut off
  geom_hline(yintercept = -log10(0.00001), linetype="dashed", size=0.25) + 
  
  #10% effect size cut-off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.1) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.1)), 
             alpha=0.4, col = "red", size=3) + 
  geom_vline(xintercept = c(10, -10), linetype = "dashed", size=0.25) +
  
  # 5% effect size cut off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.05) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.05)), 
             alpha=0.4, col = "red", size=3) + 
  geom_vline(xintercept = c(5, -5), linetype = "dashed", size=0.25) +
  
  
  # 2.5% effect size cut off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.025) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.025)), 
             alpha=0.4, col = "red", size=3) + 
  geom_vline(xintercept = c(2.5, -2.5), linetype = "dashed", size=0.25) +
  
  #label significant points
  ggrepel::geom_text_repel(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.025) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.025)),
                         mapping=aes(x=as.numeric(db)*100 , y=-log10(as.numeric(pval_no2_y1_entire)),
                                     label=cpgid),
                        size=6) + 
  
  scale_x_continuous(breaks=c(-25, -10, -5, 0, 5, 10, 25)) +
  labs(y="-log10(unadjusted p-value)", x = "Effect size (methylation %)") +
  
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size=17, angle=90, vjust = 0.5, hjust=1),
        axis.text.y = element_text(size=17),
        axis.title.x = element_text(size=19),
        axis.title.y = element_text(size=19)) +
    
  ylim(0, 6.5) +
  
  ggsave( filename="2021-02-04_CHILD_y1_volcanoplot.png",
          device = "png",
          path =  here("figures", "linear_regression"),
          width = 15,
          height = 11,
          units = "cm",
          limitsize = TRUE)
 
```



Plot marginally "significant" cpg
```{r cg13668823}

covariates_ctpcs_geno_tech_cc$cg13668823 <- adj_diff_betas_geno_cc[rownames(adj_diff_betas_geno_cc)=="cg13668823", ]



cg13668823_lm <- lm(cg13668823 ~ no2_y1_entire + sex +
              maternal_smoking_y1 + 
              maternal_education_length +
              pss_6mos + 
              csed_6mos + 
              celltype.PC1 + celltype.PC2 + 
              celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + 
              celltype.PC7 + celltype.PC8 +
              celltype.PC9 + 
              genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 +
              run + row, data=covariates_ctpcs_geno_tech_cc)


#get partial residuals for no2 and dnam 
cg13668823_res <- partialResid(cg13668823 ~ no2_y1_entire, cg13668823_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
cg13668823_res_fit <- lm(cg13668823_res$yresid ~ cg13668823_res$xresid)

summary(cg13668823_res)

ggplot(cg13668823_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, col = "#75A2D9", size=2) + 
  stat_smooth(method="lm", se=F, col="black") +
  theme_bw() +
  labs(x="Year one NO2 (ppb)", 
       y=str_wrap("Bladder cancer associated protein (BLCAP)/ Neruonatin (NNAT) cg13668823 DNA methyaltion (%)",width=40)) +
  ggtitle("Partial residual plot") +
  theme(panel.border=element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=14)) 



```





### Gene specific changes

These genes are related to the proposed pathway of air pollution action or have previously been shown to exhibit DNA methylation changes associated with prenatal air pollution exposure. 

```{r gene_specific}
#FHC is FTH1 (ferritin heavy chain 1)
#nothing maps to FOXP3
#TNFA is TNF
goi <- annotation[grep("RNF39|CYP2E1|LONP1|HIBADH|SLC25A28|PLVAP|GPR55|^CAT$|TPO|NFKB1|^NOX2|SOD1|TRX1|TRX2|GSTP1|^MT3|NQO1|HMOX1|GPX1|DDH1|^NOS2|CYP2C11|CYP7B|ALOX12$|ALOX5|^NRF2$|KEAP1|AHR$|^ARNT;|GCLC|GCLM|GSR1|SLC7A11|GPC2|GSTA1|GSTA2|GSTA3|GSTA5|GSTM1|GSTM2|GSTM3|TXN$|TXNRD1$|SRXN1|G6PD|CYP1A1|IL1A|^IL2$|^IL3$|^IL4.*IL4$|^IL5$|^IL6$|IL9$|IL10$|IL12A|IL13|IL15$|IL17A|IL18$|IL19|IL21$|IL22$|IL23A$|IL25$|IL27$|IL31$|IL33$|IFNG$|^TNF$|TGFB1$|FOXP3|FTH1", annotation$UCSC_RefGene_Name), ]

#transpose betas
diff_betas_geno_cc_cpr_t <- t(diff_betas_geno_cc_cpr)

#apply function for calculating significance of associations using mice and imputed covariate data
yearone_goi_list <- 
  pbapply(diff_betas_geno_cc_cpr_t [,colnames(diff_betas_geno_cc_cpr_t ) %in% rownames(goi)], 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_tech_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_y1_entire + sex +
              maternal_smoking_y1 + 
              maternal_education_length +
              pss_6mos + 
              csed_6mos + 
              celltype.PC1 + celltype.PC2 + 
              celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + 
              celltype.PC7 + celltype.PC8 +
              celltype.PC9 + 
              genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 +
              cb_run + cb_row +
              y1_run + y1_row + 
              sv1 + sv2 + sv3 + sv4 +
              sv5 + sv6 + sv7 + sv8 + 
              sv9 + 
              sv10 + sv11 + sv12 + sv13, data=combined)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistics
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})


yearone_goi <- do.call(rbind, yearone_goi_list)

yearone_goi$p.value.no2_y1_entire_adjusted <- p.adjust(yearone_goi$p.value.no2_y1_entire, method="bonferroni")

#reorder according ot unadjusted no2 pvalue
yearone_goi_order <- yearone_goi[order(yearone_goi$p.value.no2_y1_entire),]

#reorder goi annotation to be in same order as goi stats
goi_order <- goi[rownames(yearone_goi_order),]

#check identical
identical(rownames(goi_order), rownames(yearone_goi_order)) #true

#bind
yearone_goi_df <- cbind(yearone_goi_order, goi_order)

#write as .csv
#write.csv(yearone_goi_df, file=here("output_data", "2020-11-29_yearone_goi.csv"))


#graph two marginally significant cpgs

covariates_ctpcs_geno_tech_cc$cg18668679 <- diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg18668679", ]


cg18668679_lm <- lm(cg18668679 ~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      csed_6mos + 
                      celltype.PC1 + celltype.PC2 + 
                      celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + 
                      celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + 
                      genotyping.PC1 + genotyping.PC2 + 
                      genotyping.PC3 +
                      cb_run + cb_row +
              y1_run + y1_row +
              sv1 + sv2 + sv3 + sv4 +
              sv5 + sv6 + sv7 + sv8  + sv9, 
              data=covariates_ctpcs_geno_tech_cc)


#get partial residuals for no2 and dnam 
cg18668679_res <- partialResid(cg18668679 ~ no2_y1_entire, cg18668679_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
cg18668679_res_fit <- lm(cg18668679_res$yresid ~ cg18668679_res$xresid)

summary(cg18668679_res)

ggplot(cg18668679_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, col = "#75A2D9", size=2) + 
  stat_smooth(method="lm", se=F, col="black", linetype="dashed") +
  theme_bw() +
  labs(x="Year one NO2 (ppb)", 
       y=str_wrap("DNA methyaltion (%)",width=40)) +
  ggtitle("cg18668679 partial residual plot") +
  theme(panel.border=element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=14)) 


#AHR cpg that is close to sig
covariates_ctpcs_geno_tech_cc$cg07793849 <- diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg07793849", ]


cg07793849_lm <- lm(cg07793849 ~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      csed_6mos + 
                      celltype.PC1 + celltype.PC2 + 
                      celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + 
                      celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + 
                      genotyping.PC1 + genotyping.PC2 + 
                      genotyping.PC3 +
                                    cb_run + cb_row +
              y1_run + y1_row, data=covariates_ctpcs_geno_tech_cc)


#get partial residuals for no2 and dnam 
cg07793849_res <- partialResid(cg07793849 ~ no2_y1_entire, cg07793849_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
cg07793849_res_fit <- lm(cg07793849_res$yresid ~ cg07793849_res$xresid)

summary(cg07793849_res)

ggplot(cg07793849_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, fill = "#508FC2", shape=21, size=3) + 
  stat_smooth(method="lm", se=F, col="red") + 
  theme_bw() +
  labs(x=bquote("Year one" ~NO[2]~ "(ppb) partial residual"), 
       y="Methylation (%) partial residual") +
  annotate("text",x=7,y=0.06, label="slope = -0.03273", size=6) +
  ggtitle("cg07793849") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=19),
        axis.title = element_text(size=17),
        title = element_text(size=20)) +
  #ylim(-0.1, 0.1) +
  #xlim(NA, 16) +
  
  ggsave( filename="2021-02-05_CHILD_y1_cg07793849_AHR.png",
          device = "png",
          path =  here("figures", "linear_regression"),
          width = 12,
          height = 10,
          units = "cm",
          limitsize = TRUE)
 

#the intercept in a multiple regression model is the mean for the response when
#all of the explanatory variables take on the value
```




Examine mean methylation vs no2
```{r mean_meth}
#convert betas to df
diff_betas_geno_cc_cpr_df <- as.data.frame(diff_betas_geno_cc_cpr)

methmeans <- colMeans(diff_betas_geno_cc_cpr_df)

covariates_ctpcs_geno_tech_cc <- cbind(covariates_ctpcs_geno_tech_cc, methmeans)

#colmeans
meanmeth_lm <- lm(methmeans ~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      csed_6mos + 
                      celltype.PC1 + celltype.PC2 + 
                      celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + 
                      celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + 
                      genotyping.PC1 + genotyping.PC2 + 
                      genotyping.PC3 +
                      cb_run + cb_row +
                     y1_run + y1_row +
              sv1 + sv2 + sv3 + sv4 +
              sv5 + sv6 + sv7 + sv8 + 
              sv9 +
                sv10 + sv11 + sv12 + sv13, data=covariates_ctpcs_geno_tech_cc)

#get summary
summary(meanmeth_lm) #no2 not sig

#get partial residuals for no2 and dnam 
methmean_res <- partialResid( methmeans ~ no2_y1_entire, meanmeth_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
methmean_res_fit <- lm(methmean_res$yresid ~ methmean_res$xresid)

summary(methmean_res)

ggplot(methmean_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, col = "#75A2D9", size=2) + 
  stat_smooth(method="lm", se=F, col="black", linetype="dashed") +
  theme_bw() +
  labs(x="Year one NO2 (ppb)", y="Genome wide DNA methyaltion (%)") +
  ggtitle("Partial residual plot") +
  theme(panel.border=element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=14)) 
```





```{r get_lineannotation}
#read in line annotation
annotationlines <- read.csv(here("output_data", "linear_regression", "2020-11-29_annotation_LINEs.csv"))

#subset 
annotationlines <- annotationlines[annotationlines$LINEs==T, ]

#subset betas
diff_betas_geno_cc_cpr_lines <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr) %in%
                     annotationlines$X, ]

dim(diff_betas_geno_cc_cpr_lines)


#convert betas to df
diff_betas_geno_cc_cpr_lines_df <- as.data.frame(diff_betas_geno_cc_cpr_lines)

linemeth <- colMeans(diff_betas_geno_cc_cpr_lines_df)

covariates_ctpcs_geno_tech_cc$linemeth <- linemeth

#colmeans
linemeth_lm <- lm(linemeth ~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      csed_6mos + 
                      celltype.PC1 + celltype.PC2 + 
                      celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + 
                      celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + 
                      genotyping.PC1 + genotyping.PC2 + 
                      genotyping.PC3 +
                      cb_run + cb_row +
                     y1_run + y1_row +
              sv1 + sv2 + sv3 + sv4 +
              sv5 + sv6 + sv7 + sv8 + 
              sv9, data=covariates_ctpcs_geno_tech_cc)

summary(linemeth_lm) #no2 not sig




#get partial residuals for no2 and dnam 
linemeth_res <- partialResid( linemeth ~ no2_y1_entire, linemeth_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
linemeth_res_fit <- lm(linemeth_res$yresid ~ linemeth_res$xresid)

summary(linemeth_res_fit)

ggplot(linemeth_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, col = "#75A2D9", size=2) + 
  stat_smooth(method="lm", se=F, col="black", linetype="dashed") +
  theme_bw() +
  labs(x="Year one NO2 (ppb)", y="LINE DNA methyaltion (%)") +
  ggtitle("Partial residual plot") +
  theme(panel.border=element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=14)) 

```





Looking at cg26227465 to confirm persistence *should see no change in dnam if persistent*

```{r cg26227465}


#AHR cpg that is close to sig
covariates_ctpcs_geno_tech_cc$cg26227465 <- adj_diff_betas_geno_cc[rownames(adj_diff_betas_geno_cc)=="cg26227465", ]


cg26227465_lm <- lm(cg26227465 ~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      csed_6mos + 
                      celltype.PC1 + celltype.PC2 + 
                      celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + 
                      celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + 
                      genotyping.PC1 + genotyping.PC2 + 
                      genotyping.PC3 +
                      run + row, data=covariates_ctpcs_geno_tech_cc)


#get partial residuals for no2 and dnam 
cg26227465_res <- partialResid(cg26227465 ~ no2_y1_entire, cg26227465_lm, 
              data=covariates_ctpcs_geno_tech_cc)

#fit again to get r2
cg26227465_res_fit <- lm(cg26227465_res$yresid ~ cg26227465_res$xresid)

summary(cg26227465_res_fit)

ggplot(cg26227465_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.8, col = "#75A2D9", size=2) + 
  stat_smooth(method="lm", se=F, col="black") +
  theme_bw() +
  labs(x="Year one NO2 (ppb)", 
       y=str_wrap("IFNG DNA methyaltion (%)",width=40)) +
  ggtitle("Partial residual plot") +
  theme(panel.border=element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=14)) 



```












Try re-running limma with birth month/ interaction between birth month and air pollution.
```{r interaction_terms_to_assess_birthmonth}
#want to use anova to compare models usign anova
#anova only accepts models from lm
#use lm to compare how birth month affects cpgs above 10^-3 sig 

#You should be able to ask for confidence intervals for the slope coefficients for each month.  #even in a tabular display, you may see that “smoothly varying” pattern we were discussing.
#Then, you could use those to plot a sort of “here’s how the slope varies by month” picture.Sort #of like forest plots for meta analysis results, if that makes sense.

#Also, before we decide it doesn’t matter, the individual slopes might look fairly similar, but the appropriate overall test would be to check the anova(fit_with_interaction) and check the p-value on the interaction term.


################################################
#sig cpg
library(broom)

covariates_ctpcs_geno_tech_cc$cg13668823 <- adj_diff_betas_geno_cc[rownames(adj_diff_betas_geno_cc)=="cg13668823", ]



cg13668823_fit_bm <- lm(cg13668823 ~ no2_y1_entire + sex +
              maternal_smoking_y1 + 
              maternal_education_length +
              pss_6mos + 
              csed_6mos + 
              celltype.PC1 + celltype.PC2 + 
              celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + 
              celltype.PC7 + celltype.PC8 +
              celltype.PC9 + 
              genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 +
                birth_month +
                no2_y1_entire*birth_month +
              run + row, data=covariates_ctpcs_geno_tech_cc)



tidy(cg13668823_fit_bm, conf.int = 0.95) %>% filter(term %>% str_detect(":")) %>% 
  mutate(term = factor(term, levels=c("no2_y1_entire:birth_monthfebruary",
                                      "no2_y1_entire:birth_monthmarch",
                                      "no2_y1_entire:birth_monthapril",
                                      "no2_y1_entire:birth_monthmay",
                                      "no2_y1_entire:birth_monthjune",
                                      "no2_y1_entire:birth_monthjuly",
                                      "no2_y1_entire:birth_monthaugust",
                                      "no2_y1_entire:birth_monthseptember",
                                      "no2_y1_entire:birth_monthoctober",
                                      "no2_y1_entire:birth_monthnovember",
                                      "no2_y1_entire:birth_monthdecember"))) %>%
  ggplot(aes(y = estimate, x = as.factor(term))) + 
  geom_point() +
  geom_errorbar(aes(ymin = conf.low , ymax = conf.high)) +
  theme_bw() +
  ggtitle("cg13668823") +
  scale_x_discrete(labels=c("NO2:February","NO2:March", "NO2:April", "NO2:May",
                            "NO2:June","NO2:July", "NO2:August", "NO2:September",
                            "NO2:October", "NO2:November","NO2:December")) +
  labs(x="Interaction term", y="Estimate") +
  theme(panel.border=element_blank(),
        axis.text.x = element_text(angle=90),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=16)) 

anova(cg13668823_fit_bm)






cg18668679_fit_bm <- lm(cg18668679 ~ no2_y1_entire + sex +
              maternal_smoking_y1 + 
              maternal_education_length +
              pss_6mos + 
              csed_6mos + 
              celltype.PC1 + celltype.PC2 + 
              celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + 
              celltype.PC7 + celltype.PC8 +
              celltype.PC9 + 
              genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 +
                birth_month +
                no2_y1_entire*birth_month +
              run + row, data=covariates_ctpcs_geno_tech_cc)



tidy(cg18668679_fit_bm, conf.int = 0.95) %>% filter(term %>% str_detect(":")) %>% 
  mutate(term = factor(term, levels=c("no2_y1_entire:birth_monthfebruary",
                                      "no2_y1_entire:birth_monthmarch",
                                      "no2_y1_entire:birth_monthapril",
                                      "no2_y1_entire:birth_monthmay",
                                      "no2_y1_entire:birth_monthjune",
                                      "no2_y1_entire:birth_monthjuly",
                                      "no2_y1_entire:birth_monthaugust",
                                      "no2_y1_entire:birth_monthseptember",
                                      "no2_y1_entire:birth_monthoctober",
                                      "no2_y1_entire:birth_monthnovember",
                                      "no2_y1_entire:birth_monthdecember"))) %>%
  ggplot(aes(y = estimate, x = as.factor(term))) + 
  geom_point() +
  geom_errorbar(aes(ymin = conf.low , ymax = conf.high)) +
  theme_bw() +
  ggtitle("cg18668679") +
  scale_x_discrete(labels=c("NO2:February","NO2:March", "NO2:April", "NO2:May",
                            "NO2:June","NO2:July", "NO2:August", "NO2:September",
                            "NO2:October", "NO2:November","NO2:December")) +
  labs(x="Interaction term", y="Estimate") +
  theme(panel.border=element_blank(),
        axis.text.x = element_text(angle=90),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        title = element_text(size=16)) 

anova(cg18668679_fit_bm)
  
```








### PC analysis of covariates 

Heat scree plot
```{r heatscree}
#initialize the heatplot function 
#outputs heatmap of PCs
#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot<-function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Create column to name rows accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}



```


PC analysis
```{r pc_covariates}
#load cell type predictions
load("R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution/output_data/deconvolution/2020-11-10_CBMC_PBMC_deconvolution.Rdata")

#convert cell counts to dataframe
child_fscbc_ecc2_cb_df <- as.data.frame(child_fscbc_ecc2_cb)
child_fscbc_ecc2_y1_df <- as.data.frame(child_fscbc_ecc2_y1)

#subset cell counts for participants in pdata
child_fscbc_ecc2_cb_df_sub <-  child_fscbc_ecc2_cb_df[rownames(child_fscbc_ecc2_cb_df) %in%
                                                        rownames(cb_pdata), ]
child_fscbc_ecc2_y1_df_sub <-  child_fscbc_ecc2_y1_df[rownames(child_fscbc_ecc2_y1_df) %in%
                                                        rownames(y1_pdata_sub), ]

#check size
dim(child_fscbc_ecc2_cb_df_sub) #144
dim(child_fscbc_ecc2_y1_df_sub) #144

#check order
identical(rownames(child_fscbc_ecc2_cb_df_sub), rownames(cb_pdata)) #true
identical(rownames(child_fscbc_ecc2_cb_df_sub), rownames(y1_pdata_sub)) #false
identical(y1_pdata_sub$Sample_Label, cb_pdata$Sample_Label) #true
#reorder y1 cell counts to be in same order has y1_data
child_fscbc_ecc2_y1_df_sub_order <- child_fscbc_ecc2_y1_df_sub[rownames(y1_pdata_sub), ]
identical(rownames(child_fscbc_ecc2_y1_df_sub_order), rownames(y1_pdata_sub)) #true

#combine cell counts
colnames(child_fscbc_ecc2_y1_df_sub_order) <- 
  paste("y1", colnames(child_fscbc_ecc2_y1_df_sub_order), sep=".")

allcounts <- cbind(child_fscbc_ecc2_cb_df_sub, child_fscbc_ecc2_y1_df_sub_order)

#rename rownames to participant id (5 digit num)
rownames(allcounts) <- cb_pdata$Sample_Label

#susbet cell counts for complete cases
allcounts_cc <- 
  allcounts[rownames(allcounts) %in%
                               as.character(covariates_ctpcs_geno_tech_cc$sampleid), ]

#check size
dim(allcounts_cc) #125

#check order
identical(rownames(allcounts_cc), 
          as.character(covariates_ctpcs_geno_tech_cc$sampleid)) #true

#combine
covariates_ctpcs_geno_tech_cc <- cbind(covariates_ctpcs_geno_tech_cc,
                                       allcounts_cc)

#PCA
uncor.dat <- t(scale(t(adj_diff_betas_geno_cc)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-20

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:20)


#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
meta_categorical <- covariates_ctpcs_geno_tech_cc[,c("sex", "run", "chip", "maternal_smoking_y1")]

meta_continuous <- covariates_ctpcs_geno_tech_cc[,c("no2_y1_entire", 
                                                    "maternal_education_length", 
                                                    "csed_6mos", "pss_6mos", 
                                                    "counts.CD4T", "counts.CD8T",
                                                    "counts.NK", "counts.Bcell",
                                                    "counts.Mono", "counts.nRBC",
                                                    "y1.counts.CD4T", "y1.counts.CD8T",
                                                    "y1.counts.NK", "y1.counts.Bcell",
                                                    "y1.counts.Mono",
                                                    "row")]

heat_scree_plot(Loadings, Importance, Num, Order)


covariates_ctpcs_geno_tech_cc_num <- as.data.frame(covariates_ctpcs_geno_tech_cc)
covariates_ctpcs_geno_tech_cc_num$sex <- as.factor(covariates_ctpcs_geno_tech_cc_num$sex )
covariates_ctpcs_geno_tech_cc_num$sex <- as.numeric(covariates_ctpcs_geno_tech_cc_num$sex)
covariates_ctpcs_geno_tech_cc_num$prenatal_maternal_smoking <- as.numeric(covariates_ctpcs_geno_tech_cc_num$prenatal_maternal_smoking)
covariates_ctpcs_geno_tech_cc_num$run <- as.numeric(covariates_ctpcs_geno_tech_cc_num$run)

test <- covariates_ctpcs_geno_tech_cc_num[,c("sex", "prenatal_maternal_smoking",
                                              "gestational_days",
                                             "maternal_education_length", 
                                             "pss_18wk", "csed_18wk")]


#variance in data
#prcomp using singular value decomposition (svd)m which examines the covariances / correlations between individuals
all_pca <- prcomp(test, 
                  scale. = TRUE)

#scree plot to visualize how many PCs we need
factoextra::fviz_eig(all_pca, ncp=20) #correct on first 9 pcs

#convert to dataframe
all_pcs <- as.data.frame(all_pca$x)

#examine grouping of pcs
ggpairs(all_pcs, columns=1:10, progress=FALSE)  


#add first two pcs to covariates
covariates_ctpcs_geno_tech_cc_num <- cbind(covariates_ctpcs_geno_tech_cc_num,
                                           all_pca$x[,c("PC1", "PC2", "PC3")])


#create model matrix
cb_design <- model.matrix(~no2_preg_entire + 
                            PC1 +
                            cbmc.PC1 + cbmc.PC2+
                            cbmc.PC3 + cbmc.PC4 + cbmc.PC5 +
                            genotyping.PC1 +
                            genotyping.PC2 +
                            genotyping.PC3 + row + run,
                          data=covariates_ctpcs_geno_tech_cc_num)

#check size
dim(cb_design) #101


#subset betas
cb_betas_geno_cc <- 
  cb_betas_geno[,colnames(cb_betas_geno) %in% covariates_ctpcs_geno_tech_cc_num$sampleid]
#check size
dim(cb_betas_geno_cc) #101

#fit methylation to no2
cb_fit <-  lmFit(cb_betas_geno_cc, cb_design)
cb_ebayes <- eBayes(cb_fit)

#add annotation to cb_ebayes
cb_ebayes$annotation <- annotation[rownames(annotation) %in% rownames(cb_ebayes),]

#pull out pval, coefficients and annotation
cb_pvals_tech <- cbind(as.data.frame(cb_ebayes$p.value), 
                  as.data.frame(cb_ebayes$coefficients),
                  as.data.frame(cb_ebayes$annotation))

#rename columns to indicate pvalues vs coeffcients 
colnames(cb_pvals_tech) <- c(paste("pval", colnames(cb_pvals_tech)[1:13], sep = "_"), 
                         paste("coeff", colnames(cb_pvals_tech)[14:26], sep = "_"),
                         colnames(cb_pvals_tech)[27:59])

ggplot( data = cb_pvals_tech, aes(x=pval_no2_preg_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 
```



Next examine correlation bewteen variables.
```{r corr}

cor2 = function(df){
  
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  cor_fun <- function(pos_1, pos_2){
    
    # both are numeric
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
      print("both are numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      r <- stats::cor(df[[pos_1]], df[[pos_2]], use = "pairwise.complete.obs")
    }
    
    #one is numberic the other is factor/character
    #must use sum of squares type 3 because groups are not of the same size
    #calculates ANOVA
    #then calcualtes eta-squared: measures the proportion of the total variance in a      dependent variable that
    #is associated with the membership of different groups defined by an independent      variable.
    #takes square root to get correlation
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        r <- 999
      } else {
        #anova for correlation
        r <- stats::aov(df[[pos_1]] ~ as.factor(df[[pos_2]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
      }
      rm(tmp,tmp2)
    }
    
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        r <- stats::aov(df[[pos_2]] ~ as.factor(df[[pos_1]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
      }
      rm(tmp,tmp2)
    }
    
    
    #both are factor/character
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
          r <-999
        } else { 
          r <- lsr::cramersV(df[[pos_1]], df[[pos_2]], simulate.p.value = TRUE)
        }
      }
      rm(tmp,tmp2)
    }
    return(r)
  } 
  
  cor_fun <- Vectorize(cor_fun)
  
  # now compute corr matrix
  corrmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) cor_fun(x, y)
  )
  
  rownames(corrmat) <- colnames(df)
  colnames(corrmat) <- colnames(df)
  return(corrmat)
}


pval2 = function(df){
  
  #check that classes are appropriate
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  
  ##################################
  #function for calculating pvalues#
  ##################################
  
  pval_fun <- function(pos_1, pos_2){
    

    ##################
    #both are numeric#
    ##################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
        
      print("both are numeric")
      
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        #dont want to star comparisons of something against itsself
        p <- 1
      } else {
        print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
        p <- unname((summary(lm(df[[pos_1]] ~ df[[pos_2]]))$coefficients[,4])[2])
      }
    }
  
    ########################################
    #first is integer and second is numeric#
    ########################################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        p <- 999
      } else {
       if(nlevels(droplevels(tmp2[,2]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_1]] ~ as.factor(df[[pos_2]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_1]] ~ as.factor(df[[pos_2]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ########################################
    #second is integer and first is numeric#
    ########################################
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        p <- 999
      } else {
        if(nlevels(droplevels(tmp2[,1]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_2]] ~ as.factor(df[[pos_1]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_2]] ~ as.factor(df[[pos_1]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ###########################
    #both are factor/character#
    ###########################
    
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        p <- 1
      } else {
        if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
          p <- 999
        } else {
          if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
            p <- 999
          } else {
            #get p value
            fish_table <- table(df[[pos_1]], df[[pos_2]])
            p <- fisher.test(fish_table, simulate.p.value = T)$p.value
          }
        }
      }
      rm(tmp,tmp2)
    }
    return(p)
  } 
  
  pval_fun <- Vectorize(pval_fun)
  
  # now compute corr matrix
  pvalmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) pval_fun(x, y)
  )
  
  rownames(pvalmat) <- colnames(df)
  colnames(pvalmat) <- colnames(df)
  return(pvalmat)
}

#early exp and pn_18 are the same thing. 
#exclude early_exp from correlation matrices
corr <- round(cor2(covariates_ctpcs_geno_tech_cc %>% 
                select(-no_vaccines_6mos,
                       -clinician_wheeze_dx_y3,
                       -reported_asthma_dx_y1,
                       -move_6m, -move_3m)))

pval <- pval2(covariates_ctpcs_geno_tech_cc %>% 
                select(-no_vaccines_6mos,
                       -clinician_wheeze_dx_y3,
                       -reported_asthma_dx_y1,
                       -move_6m, -move_3m))


corrsub <- corr[,136:151]
pvalsub <- pval[,136:150]

ggcorrplot(corr=corrsub,
           #p.mat=pvalsub,
           #insig = "blank",
           type = "lower", 
           #lab=TRUE,
           #lab_size = 2,
           tl.cex =6, 
           colors = c("#6D9EC1", "white", "#E46726")) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        legend.position="left") +
  scale_y_discrete(position = "right")


```

