---
title: "CHILD NO2 birth linear model sensitivity analysis"
author: "SL"
date: "18/11/2020"
output: html_document
---

*Purpose*: The purpose of this script is to identify the best linear model for birth no2 linear models in CHILD. 


Load required libraries.
```{r libraries}
library(tidyverse)
library(limma)
library(modelr)
library(broom)
library(here)
```

Load covariate data
```{r covariates}
load(file=here("output_data", "covariates", "2020-11-12_CHILD_covariates_na_with_means.Rdata"))
```


Load DNAm data and pdata. Subset out cord blood samples.
```{r pdata}
load(file=here("output_data", "preprocessed_data", "2020-11_10_CHILD_preprocessed_mvals_pdata_annotation.Rdata"))

#check ranges to confirm DNAm data is in m-value format
dim(mval_batchcorr)
max(mval_batchcorr)
min(mval_batchcorr)

#subset pData into CBMCs (cord blood)
#these children have data at both time points
cb_pdata <- subset(pdata_nodups, Tissue == "C")
dim(cb_pdata)

#subset cordblood DNAM samples
cb_mval_batchcorr <- mval_batchcorr[ ,colnames(mval_batchcorr) %in% rownames(cb_pdata)]

#check size for correct sample num
dim(cb_mval_batchcorr) #144

#convert mvals to beta values 
#beta values will be used in linear regression because of substraction used on year one data (which has to be done on beta values). using the same format will make the data more comparable.
cb_beta_batchcorr <- lumi::m2beta(cb_mval_batchcorr)
min(cb_beta_batchcorr)
max(cb_beta_batchcorr)

#rename colnames of beta values to sample label
#create new column in pdata
cb_pdata$sentrix_name <- paste(cb_pdata$Sentrix_ID, cb_pdata$Sentrix_Position, sep="_")
identical(colnames(cb_beta_batchcorr), cb_pdata$sentrix_name)#true
colnames(cb_beta_batchcorr) <- cb_pdata$Sample_Label
```

Subset covariates for individuals with cord blood DNAm.
```{r sub_covariates}
covariates_sub <- covariates_nameans[as.character(covariates_nameans$sampleid) %in% colnames(cb_beta_batchcorr), ]

#check if they are in the same order
identical(as.character(covariates_sub$sampleid), colnames(cb_beta_batchcorr)) #true
```


Load CBMC PCs.
```{r load_PC_correctedbetas}
load(here("output_data", "deconvolution", "2020-11-10_CBMC_PCs.Rdata"))

dim(cb_pcs) #144 6

#rename columns for clarity
colnames(cb_pcs) <- paste("cbmc.", colnames(cb_pcs), sep="")
```


Load genotyping PCs and subset out REEGLE PCs (genotyping data contains PCs for a few thousand participants).
```{r genotypingPCS}
genotyping <- read.csv("R:/Jones/People/Samantha Lee/Computational/CHILD/input_data/CHILD_subjects_Qced_first10PCS_Duan.csv")

#make rownames sample names then rmove this row
rownames(genotyping) <- genotyping$FID
genotyping <- subset(genotyping, select=-c(FID, IID))

genosub <- genotyping[rownames(genotyping) %in% cb_pdata$Sample_Label,]
#missing genotyping data for 14 REEGLE children?

#rename columns of genotyping data for clarity
colnames(genosub) <- paste("genotyping.", colnames(genosub), sep="")
```


Check that betas, pdata, covariates, cell type PCs are in same order.
```{r cb_batchcorr_order}
#check that pdata and betas are in correct order
identical(as.character(cb_pdata$Sample_Label), colnames(cb_beta_batchcorr)) #true

#check that pdata and covariates are in the same order
identical(as.character(cb_pdata$Sample_Label), as.character(covariates_sub$sampleid)) #true

#check that pdata and cell type pcs are in same order
identical(rownames(cb_pdata), rownames(cb_pcs)) #true
```


Add cell type PCs to covariate data
```{r combine_cell_pcs_covariates}
covariates_ctpcs <- cbind(covariates_sub, cb_pcs)
```


Subset covariates, pdata, and betas for individuals that have genotyping data. Add genotyping pcs to covariates
```{r sub_on_geno}
#subset covariates
covariates_ctpcs_sub <- covariates_ctpcs[covariates_ctpcs$sampleid %in% rownames(genosub), ]
dim(covariates_ctpcs_sub) #131

#check that covariates and geno are in same order
identical(as.character(covariates_ctpcs_sub$sampleid), rownames(genosub)) #false

#put genosub rows in numerical order
genosub_order <- genosub[order(rownames(genosub)), ]

#check that covariates and geno are in same order
identical(as.character(covariates_ctpcs_sub$sampleid), rownames(genosub_order)) #true

#combine genosub with covariates
covariates_ctpcs_geno <- cbind(covariates_ctpcs_sub, genosub_order)

#subet betas for genotyping data
cb_beta_batchcorr_geno <- cb_beta_batchcorr[,colnames(cb_beta_batchcorr) %in% rownames(genosub_order)] 
dim(cb_beta_batchcorr_geno) #131

#check that this is in the same order as covariates
identical(as.character(covariates_ctpcs_geno$sampleid), colnames(cb_beta_batchcorr_geno)) #true

#subset pdata
cb_pdata_geno <- cb_pdata[as.character(cb_pdata$Sample_Label) %in% rownames(genosub_order), ]
dim(cb_pdata_geno) #131 16

#check that covariates and dpata are in same order
identical(as.character(cb_pdata_geno$Sample_Label), as.character(covariates_ctpcs_geno$sampleid)) #true
```

Subset beta values for complete cases.
```{r beta_cc}
#further subset covariates and beta values for complete cases
#subset covariates
covariates_ctpcs_geno_cc <- 
  covariates_ctpcs_geno[complete.cases(covariates_ctpcs_geno %>% 
                                         dplyr::select(no2_preg_entire, sex, birth_month,
                                                       gestational_days, 
                                                       maternal_smoking_18wk, 
                                                       maternal_education_length,
                                                       pss_18wk, 
                                                       cbmc.PC1, cbmc.PC2,
                                                       cbmc.PC3, cbmc.PC4,cbmc.PC5,
                                                       genotyping.PC1, genotyping.PC2,
                                                       genotyping.PC3)), ] 
#check size
dim(covariates_ctpcs_geno_cc) #101

#subset betas
cb_beta_batchcorr_geno_cc <- cb_beta_batchcorr_geno[,colnames(cb_beta_batchcorr_geno) %in% covariates_ctpcs_geno_cc$sampleid]
#check size
dim(cb_beta_batchcorr_geno_cc) #101
```


Limma contains its own function to assess model fit using AIC/BIC called "selectModel". This function allows comparison of different model matrices to determine the best model for each probe. As this is the simplest way to compare models using currently implemented code, start with this.
```{r limma_aicbic}
#create design matrix for all covariates
design_all <- model.matrix(~no2_preg_entire + sex + 
                             birth_month + 
                             gestational_days +
                             maternal_smoking_18wk + 
                             maternal_education_length +
                             pss_18wk + 
                             cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
                             cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
                             genotyping.PC3,
                           data=covariates_ctpcs_geno)

#check size
dim(design_all) #101


#create model matrix that excludes birth month
design_nobm <- model.matrix(~no2_preg_entire + sex +  
                              gestational_days +
                              maternal_smoking_18wk + 
                              maternal_education_length +
                              pss_18wk + 
                              cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
                              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
                              genotyping.PC3,
                            data=covariates_ctpcs_geno)

#check size
dim(design_nobm) #101

#compare the two model matrices using limma's selectModel function

#AIC is better in situations when a false negative finding would be considered more misleading than a false positive
modelfit_aic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm),
                        criterion = "aic")

#what model is preferred at most probes
table(modelfit_aic$pref) #the model without birth month is preferred


#BIC is better in situations where a false positive is as misleading as, or more misleading than, a false negative
#BIC is more appropriate for this study
modelfit_bic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm),
                        criterion = "bic")

#what model is preferred at most probes
table(modelfit_bic$pref) #the model without birth month is STRONGLY preferred
```


Now compare distribution of rmse of model with birth month and without month. Need to rerun linear regressions using lm since limma does not provide the required info.
```{r rmse_birthmonth}
#transpose for lm
cb_beta_batchcorr_geno_cc_t <- t(cb_beta_batchcorr_geno_cc)

#lm takes a long time to run 
#randomly select 50 000 cpgs to use for rmse to reduce computational time
set.seed(1234)
randcols <- sample(1:ncol(cb_beta_batchcorr_geno_cc_t), 10000, replace=F)
beta_sub <- cb_beta_batchcorr_geno_cc_t[,randcols]

#rmse of model with birth month
dnam_stats_list_bm <- pbapply(beta_sub, 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_preg_entire + sex + birth_month + gestational_days +
              maternal_smoking_18wk +
              maternal_education_length +
              pss_18wk + cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
              genotyping.PC3, data=combined)
  
  #calculate RMSE from fit
  #Residual sum of squares:
  RSS <- c(crossprod(fit$residuals))
  
  #Mean squared error:
  MSE <- RSS / length(fit$residuals)
  
  #Root MSE:
  RMSE <- sqrt(MSE)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistic
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value, RMSE)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})

dnam_stats_bm <- do.call(rbind, dnam_stats_list_bm)


#rmse of model with birth month
dnam_stats_list_nobm <- pbapply(beta_sub, 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_preg_entire + sex + gestational_days +
              maternal_smoking_18wk +
              maternal_education_length +
              pss_18wk + cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
              genotyping.PC3, data=combined)
  
  #calculate RMSE from fit
  #Residual sum of squares:
  RSS <- c(crossprod(fit$residuals))
  
  #Mean squared error:
  MSE <- RSS / length(fit$residuals)
  
  #Root MSE:
  RMSE <- sqrt(MSE)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistic
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value, RMSE)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})

dnam_stats_nobm <- do.call(rbind, dnam_stats_list_nobm)

#use paired wilcoxon rank sum test to determine if rmse of nobm is lower than bm
test <- wilcox.test(dnam_stats_bm$RMSE, 
                    dnam_stats_nobm$RMSE,
                    alternative = "less",
                    paired=TRUE) # no difference

rmses <- as.data.frame(cbind(nobm = dnam_stats_nobm$RMSE, 
               bm= dnam_stats_bm$RMSE))

rmses_long <- gather(rmses, model, rmse)

ggplot(rmses_long, aes(x=-log10(rmse), group = model, col=model)) +
  geom_density(size=2) +
  scale_color_manual(values=c("#393E41", "#E94F37")) +
  theme_bw() +
  theme(panel.border = element_blank())
```



What if we use temperature/season to predict effects of NO2.
```{r temp}
#read in to just get temp
winnipeg <- read.csv(file=here("raw_data", "annual_temps", "winnipeg-normals-1981-2010.csv"),
                     sep=",",
                     skip=14,
                     nrows= 6,
                     header=T)

edmonton <- read.csv(file=here("raw_data", "annual_temps", "edmonton_normals_1981-2010.csv"),
                     sep=",",
                     skip=13,
                     nrows= 6,
                     header=T)

toronto <- read.csv(file=here("raw_data", "annual_temps", "toronto-normals-1981-2010.csv"),
                     sep=",",
                     skip=13,
                     nrows= 6,
                     header=T)

vancouver <- read.csv(file=here("raw_data", "annual_temps", "vancouver-normals-1981-2010.csv"),
                     sep=",",
                     skip=14,
                     nrows= 6,
                     header=T)


#clean up temp data frames by removing unneeded columns
rownames(winnipeg) <- winnipeg[,1]
rownames(edmonton) <- edmonton[,1]
rownames(toronto) <- toronto[,1]
rownames(vancouver) <- vancouver[,1]

winnipeg <- winnipeg[-c(1), -c(1,14:15)]
edmonton <- edmonton[-c(1), -c(1,14:15)]
toronto <- toronto[-c(1), -c(1,14:15)]
vancouver <- vancouver[-c(1), -c(1,14:15)]

winnipeg <- as.data.frame(t(winnipeg))
edmonton <- as.data.frame(t(edmonton))
toronto <- as.data.frame(t(toronto))
vancouver <- as.data.frame(t(vancouver))

#get cold months
winnipeg_cold <- 
  rownames(winnipeg[winnipeg$`Daily Average (Â°C)` < median(winnipeg$`Daily Average (Â°C)`),])
#change to long form
winnipeg_cold <- c("january", "february", "march", "april", "november", "december")
#conception months resulting in a >=5 months cold gestation
wpg_cold_gest <- c("august","september","october", "november", "december", "january")

#get cold months
edmonton_cold <- 
  rownames(winnipeg[edmonton$`Daily Average (Â°C)` < median(edmonton$`Daily Average (Â°C)`),])
#change to long form
edmonton_cold <- c("january", "february", "march", "october", "november", "december")
#conception months resulting in a >=5 months cold gestation
ed_cold_gest <- c("july", "august","september","october", "november", "december")

#get cold months
toronto_cold <- 
  rownames(winnipeg[toronto$`Daily Average (Â°C)` < median(toronto$`Daily Average (Â°C)`),])
#change to long form
toronto_cold <- c("january", "february", "march", "april", "november", "december")
#conception months resulting in a >=5 months cold gestation
to_cold_gest <- c("august","september","october", "november", "december", "january")

#gett cold months
vancouver_cold <- 
  rownames(winnipeg[vancouver$`Daily Average (Â°C)` < median(vancouver$`Daily Average (Â°C)`),])
#change to long form
vancouver_cold <- c("january", "february", "march", "april", "november", "december")
#conception months resulting in a >=5 months cold gestation
van_cold_gest <- c("august","september","october", "november", "december", "january")


#add whether children were cold or warm gestational babies
covariates_ctpcs_geno_cc$temp 

#babies in warm periods should have more accurate no2 exposures
covariates_ctpcs_geno_cc$temp <- 
apply(covariates_ctpcs_geno_cc, 1, function(x){
  #winnipeg
  ifelse(x["studycentre"]=="Winnipeg" & (x["birth_month"] %in% wpg_cold_gest), "cold",
         ifelse(x["studycentre"]=="Winnipeg" & !(x["birth_month"] %in% wpg_cold_gest), "warm",
                #edmonton
                ifelse(x["studycentre"]=="Edmonton" & (x["birth_month"] %in% ed_cold_gest),"cold",
                       ifelse(x["studycentre"]=="Edmonton" & !(x["birth_month"] %in% ed_cold_gest),
                              "warm",
                              #toronto
                              ifelse(x["studycentre"]=="Toronto" & (x["birth_month"]%in%
                                                                       to_cold_gest), "cold",
                                     ifelse(x["studycentre"]=="Toronto" & !(x["birth_month"] %in%
                                                                           to_cold_gest),"warm",
                                            #vancouvers
                                            ifelse(x["studycentre"]=="Vancouver" &
                                                     (x["birth_month"] %in% van_cold_gest), "cold",
                                                   ifelse(x["studycentre"]=="Vancouver" &
                                                            !(x["birth_month"] %in% van_cold_gest),
                                                          "warm", NA))))))))
})

```


Compare linear models with all covariates, without birth month, and with temp instead of birth month.
```{r temp_compare}
#temperature model
design_temp <- model.matrix(~no2_preg_entire + sex +  gestational_days +
                              temp + 
                            maternal_smoking_18wk + 
                            maternal_education_length +
                            pss_18wk + 
                            cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
                            cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
                            genotyping.PC3,
                          data=covariates_ctpcs_geno_cc)

#check size
dim(design_temp) #101


#AIC is better in situations when a false negative finding would be considered more misleading than a false positive
modelfit_aic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm, design_temp),
                        criterion = "aic")

#what model is preferred at most probes
table(modelfit_aic$pref) #the model without birth month is still preferred


#BIC is better in situations where a false positive is as misleading as, or more misleading than, a false negative
#BIC is more appropriate for this study
modelfit_bic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm, design_temp),
                        criterion = "bic")

#what model is preferred at most probes
table(modelfit_bic$pref) #the model without birth month is preferred




#rmse of model with birth month
dnam_stats_list_temp <- pbapply(beta_sub, 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_preg_entire + sex + gestational_days +
              temp +
              maternal_smoking_18wk +
              maternal_education_length +
              pss_18wk + cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
              genotyping.PC3, data=combined)
  
  #calculate RMSE from fit
  #Residual sum of squares:
  RSS <- c(crossprod(fit$residuals))
  
  #Mean squared error:
  MSE <- RSS / length(fit$residuals)
  
  #Root MSE:
  RMSE <- sqrt(MSE)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistic
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value, RMSE)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})

dnam_stats_temp <- do.call(rbind, dnam_stats_list_temp)

rmses <- as.data.frame(cbind(temp = dnam_stats_temp$RMSE, 
               rmses))

#use paired wilcoxon rank sum test to determine if rmse of nobm is lower than bm
test2 <- wilcox.test(dnam_stats_temp$RMSE,
                    dnam_stats_bm$RMSE,
                    alternative = "less",
                    paired=T) # no difference

rmses <- as.data.frame(cbind(temp = dnam_stats_temp$RMSE, 
               rmses))

rmses_long <- gather(rmses, model, rmse)

ggplot(rmses_long, aes(x=-log10(rmse), group = model, col=model)) +
  geom_density(size=2) +
  scale_color_manual(values=c("#393E41", "#E94F37", "yellow")) +
  theme_bw() +
  theme(panel.border = element_blank()) 
```


What if we split according to seasons as defined by equinox.
```{r seasons}

summer = c("june", "july", "august")
fall = c("september", "october", "november")
winter = c("december", "january", "february")
spring = c("march", "april", "may")


covariates_ctpcs_geno_cc$season <- 
  apply(covariates_ctpcs_geno_cc, 1, function(x){
    ifelse((x["birth_month"] %in% summer), "summer",
           ifelse((x["birth_month"] %in% spring), "spring",
                  ifelse((x["birth_month"] %in% fall),"fall",
                         ifelse((x["birth_month"] %in% winter),"winter", NA))))
  })
```


Compare seasonal model with other models. 
```{r season_compare}

#temperature model
design_season <- model.matrix(~no2_preg_entire + sex +  gestational_days +
                                season + 
                                maternal_smoking_18wk + 
                                maternal_education_length +
                                pss_18wk + 
                                cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
                                cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
                                genotyping.PC3,
                              data=covariates_ctpcs_geno_cc)

#check size
dim(design_season) #101


#AIC is better in situations when a false negative finding would be considered more misleading than a false positive
modelfit_aic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm, design_temp, design_season),
                        criterion = "aic")

#what model is preferred at most probes
table(modelfit_aic$pref) #the model without birth month is still preferred


#BIC is better in situations where a false positive is as misleading as, or more misleading than, a false negative
#BIC is more appropriate for this study
modelfit_bic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_all, design_nobm, design_temp, design_season),
                        criterion = "bic")

#what model is preferred at most probes
table(modelfit_bic$pref) #the model without birth month is preferred


#rmse of model with season
dnam_stats_list_season <- pbapply(beta_sub, 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_preg_entire + sex + gestational_days +
              season +
               maternal_smoking_18wk +
              maternal_education_length +
              pss_18wk + cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
              genotyping.PC3, data=combined)
  
  #calculate RMSE from fit
  #Residual sum of squares:
  RSS <- c(crossprod(fit$residuals))
  
  #Mean squared error:
  MSE <- RSS / length(fit$residuals)
  
  #Root MSE:
  RMSE <- sqrt(MSE)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistic
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value, RMSE)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})

dnam_stats_season <- do.call(rbind, dnam_stats_list_season)

rmses <- as.data.frame(cbind(season = dnam_stats_season$RMSE, 
               rmses))

#use paired wilcoxon rank sum test to determine if rmse of nobm is lower than bm
test3 <- wilcox.test(dnam_stats_bm$RMSE,
                    dnam_stats_season$RMSE,
                    alternative = "less",
                    paired=T) # no difference

rmses <- as.data.frame(cbind(season = dnam_stats_season$RMSE, 
               rmses))

rmses_long <- gather(rmses, model, rmse)

ggplot(rmses_long, aes(x=-log10(rmse), group = model, col=model)) +
  geom_density(size=2) +
  scale_color_manual(values=c("#393E41", "#E94F37", "yellow", "#9CF6F6")) +
  theme_bw() +
  theme(panel.border = element_blank())
```


Should stress be included. Compare with an without
```{r stress}
#temperature model
design_nostress <- model.matrix(~no2_preg_entire + sex +  gestational_days +
                                maternal_smoking_18wk + 
                                maternal_education_length +
                                cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
                                cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
                                genotyping.PC3,
                              data=covariates_ctpcs_geno_cc)

dim(design_nostress) #101

#AIC is better in situations when a false negative finding would be considered more misleading than a false positive
modelfit_aic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_nobm, design_nostress),
                        criterion = "aic")

#what model is preferred at most probes
table(modelfit_aic$pref) #the model without birth month is still preferred


#BIC is better in situations where a false positive is as misleading as, or more misleading than, a false negative
#BIC is more appropriate for this study
modelfit_bic <- selectModel(cb_beta_batchcorr_geno_cc, 
                        designlist = list(design_nobm, design_nostress),
                        criterion = "bic")

#what model is preferred at most probes
table(modelfit_bic$pref) #the model without birth month is preferred


#rmse of model with no bm no stress
dnam_stats_list_nostress <- pbapply(beta_sub, 2, function(x) {
  
  combined <- cbind(covariates_ctpcs_geno_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_preg_entire + sex + gestational_days +
               maternal_smoking_18wk +
              maternal_education_length +
               cbmc.PC1 + cbmc.PC2 + cbmc.PC3 + 
              cbmc.PC4 + cbmc.PC5 + genotyping.PC1 + genotyping.PC2 +
              genotyping.PC3, data=combined)
  
  #calculate RMSE from fit
  #Residual sum of squares:
  RSS <- c(crossprod(fit$residuals))
  
  #Mean squared error:
  MSE <- RSS / length(fit$residuals)
  
  #Root MSE:
  RMSE <- sqrt(MSE)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistic
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value, RMSE)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})

dnam_stats_nostress <- do.call(rbind, dnam_stats_list_nostress)

rmses <- as.data.frame(cbind(nostress = dnam_stats_nostress$RMSE, 
               rmses))

#use paired wilcoxon rank sum test to determine if rmse of nobm is lower than bm
test4 <- wilcox.test(dnam_stats_nobm$RMSE,
                    dnam_stats_nostress$RMSE,
                    alternative = "less",
                    paired=T) # no difference

rmsestress <- as.data.frame(cbind(season = dnam_stats_season$RMSE, 
               rmses))

rmses_long <- gather(rmses, model, rmse)

ggplot(rmses_long %>% subset(model=="nobm" | model=="nostress"), 
       aes(x=-log10(rmse), group = model, col=model)) +
  geom_density(size=2) +
  scale_color_manual(values=c("#393E41", "#E94F37", "yellow", "#9CF6F6")) +
  theme_bw() +
  theme(panel.border = element_blank())
```



```{r all}
#fit methylation to no2
all_fit <-  lmFit(cb_beta_batchcorr_geno_cc, design_all)
all_ebayes <- eBayes(all_fit)

#add annotation to cb_ebayes
all_ebayes$annotation <- annotation[rownames(annotation) %in% rownames(all_ebayes),]

#pull out pval, coefficients and annotation
all_pvals <- cbind(as.data.frame(all_ebayes$p.value), 
                  as.data.frame(all_ebayes$coefficients),
                  as.data.frame(all_ebayes$annotation))

#rename columns to indicate pvalues vs coeffcients 
colnames(all_pvals) <- c(paste("pval", colnames(all_pvals)[1:26], sep = "_"), 
                         paste("coeff", colnames(all_pvals)[27:52], sep = "_"),
                         colnames(all_pvals)[53:85])

all_pvals$pval_no2_preg_entire_adj <- p.adjust(all_pvals$pval_no2_preg_entire, method="BH")

#histogram
ggplot( data = all_pvals, aes(x=pval_no2_preg_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 

```


no birth month
```{r no_birthmonth}
#fit methylation to no2
nobm_fit <-  lmFit(cb_beta_batchcorr_geno_cc, design_nobm)
nobm_ebayes <- eBayes(nobm_fit)

#add annotation to cb_ebayes
nobm_ebayes$annotation <- annotation[rownames(annotation) %in% rownames(nobm_ebayes),]

#pull out pval, coefficients and annotation
nobm_pvals <- cbind(as.data.frame(nobm_ebayes$p.value), 
                  as.data.frame(nobm_ebayes$coefficients),
                  as.data.frame(nobm_ebayes$annotation))

#rename columns to indicate pvalues vs coeffcients 
colnames(nobm_pvals) <- c(paste("pval", colnames(nobm_pvals)[1:15], sep = "_"), 
                         paste("coeff", colnames(nobm_pvals)[16:30], sep = "_"),
                         colnames(nobm_pvals)[31:63])

nobm_pvals$pval_no2_preg_entire_adj <- p.adjust(nobm_pvals$pval_no2_preg_entire, method="BH")

#histogram
ggplot( data = nobm_pvals, aes(x=pval_no2_preg_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 

```




no birth month no stress
```{r no_birthmonth_nostress}
#fit methylation to no2
nostress_fit <-  lmFit(cb_beta_batchcorr_geno_cc, design_nostress)
nostress_ebayes <- eBayes(nostress_fit)

#add annotation to cb_ebayes
nostress_ebayes$annotation <- annotation[rownames(annotation) %in% rownames(nostress_ebayes),]

#pull out pval, coefficients and annotation
nostress_pvals <- cbind(as.data.frame(nostress_ebayes$p.value), 
                  as.data.frame(nostress_ebayes$coefficients),
                  as.data.frame(nostress_ebayes$annotation))

#rename columns to indicate pvalues vs coeffcients 
colnames(nostress_pvals) <- c(paste("pval", colnames(nostress_pvals)[1:14], sep = "_"), 
                         paste("coeff", colnames(nostress_pvals)[15:28], sep = "_"),
                         colnames(nostress_pvals)[29:61])

nostress_pvals$pval_no2_preg_entire_adj <- p.adjust(nostress_pvals$pval_no2_preg_entire, method="BH")

#histogram
ggplot( data = nostress_pvals, aes(x=pval_no2_preg_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 

```

Plot all 3 together
```{r models_hists}

modelpvals <- as.data.frame(cbind(all = all_pvals$pval_no2_preg_entire,
                    nobm = nobm_pvals$pval_no2_preg_entire,
                    nostress = nostress_pvals$pval_no2_preg_entire))

modelpvals_long <-  gather(modelpvals, model, pval)

#histogram
ggplot( data = modelpvals_long, aes(x=pval, group=model, fill=model)) +
  geom_density(alpha=0.4) +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 


```