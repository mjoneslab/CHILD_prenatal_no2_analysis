---
title: "Covariate correlations between age one cell type proportions"
author: "SL"
date: "11/06/2020"
output: html_document
---

Read libraries in.
```{r libraries, warnings=FALSE, message=FALSE}
library(tidyverse)
library(plyr)
library(pheatmap)
library(ggpubr)
library(here)
```


Load pData.  
```{r load_pData}
#this pdata has bad samples removed and sample mix-up corrected
load(file = here("output_data", "preprocessed_data", "2021-01_14_CHILD_preprocessed_betas_pdata_annotation.Rdata"))

#subset pData into PBMCs (year 1)
y1_pdata <- subset(pdata_nodups, Tissue == "P")
dim(y1_pdata)

#subset for samples that data at birth and year one
y1_pdata_sub <- y1_pdata[y1_pdata$Sample_Label %in% pdata_nodups[pdata_nodups$Tissue == "C", "Sample_Label" ], ]

dim(y1_pdata_sub) #144 15

#rename rows and create a new column for old row names
y1_pdata_sub$sample_names <- rownames(y1_pdata_sub)
rownames(y1_pdata_sub) <- y1_pdata_sub$Sample_Label
```


Load in CHILD covariate data.
```{r covariates}
load(here("output_data", "covariates", "2020-11-12_CHILD_covariates_na_with_means.Rdata"))

#check size
dim(covariates_nameans) #145 113

#rename rows
rownames(covariates_nameans) <- covariates_nameans$sampleid
```


Read in cell type estimates.  
```{r load_deconvolution}
load(file=here("output_data", "deconvolution", "2021-01-07_CBMC_PBMC_deconvolution.Rdata"))

#convert to dataframe
child_fscbc_ecc2_y1_df <- as.data.frame(child_fscbc_ecc2_y1$counts)

#check size
dim(child_fscbc_ecc2_y1_df) # 145

#subset for samples in pdata_sub
child_fscbc_ecc2_y1_df_sub <- child_fscbc_ecc2_y1_df[rownames(child_fscbc_ecc2_y1_df) %in%
                                                       as.character(y1_pdata_sub$sample_names),]

#check size
dim(child_fscbc_ecc2_y1_df_sub) #144

#check if rownames are in same order as pdata
identical(rownames(child_fscbc_ecc2_y1_df_sub), as.character(y1_pdata_sub$sample_names)) # TRUE

#reformat rownames to be in sample id format (5 digits)
rownames(child_fscbc_ecc2_y1_df_sub) <- rownames(y1_pdata_sub)
```


Read in cell type PCs
```{r load_celltype_pcs}
load(here("output_data", "deconvolution", "2020-12-10_PBMC_PCs.RData"))

#rename columns
colnames(y1_pcs) <- paste("y1.", colnames(y1_pcs), sep="")

#check size
dim(y1_pcs) #145

#subset for samples in pdata_sub
y1_pcs_sub <- y1_pcs[rownames(y1_pcs) %in% as.character(y1_pdata_sub$sample_names),]

#check size
dim(y1_pcs_sub) # 144 5

#rename rows
identical(rownames(y1_pcs_sub), as.character(y1_pdata_sub$sample_names)) #TRUE
rownames(y1_pcs_sub) <- rownames(y1_pdata_sub)
```


Read in genotyping PCS
```{r genotyping}
genotyping <- read.csv("R:/Jones/People/Samantha Lee/Computational/CHILD/input_data/CHILD_subjects_Qced_first10PCS_Duan.csv")

#make rownames sample names then rmove this row
rownames(genotyping) <- genotyping$FID
genotyping <- subset(genotyping, select=-c(FID))

#subset genotyping for REEGLE children
genosub <- genotyping[rownames(genotyping) %in% rownames(y1_pdata_sub),]

#check size
dim(genosub) #131 11

#rename columns of genotyping data for clarity
colnames(genosub) <- paste("genotyping.", colnames(genosub), sep="")
```


Subset pdata, covariates, cell counts, and cell PCs for samples in genotyping data.
```{r subset_data_on_geno}
#subset y1_pdata
y1_pdata_sub_geno <- y1_pdata_sub[rownames(genosub), ]
dim(y1_pdata_sub_geno) #131

#subset covariates
covariates_nameans_geno <- covariates_nameans[rownames(genosub), ]
dim(covariates_nameans_geno) #131

#subset cell counts
child_fscbc_ecc2_y1_df_sub_geno <- child_fscbc_ecc2_y1_df_sub[rownames(genosub), ]
dim(child_fscbc_ecc2_y1_df_sub_geno)

#subset cell type PCs
y1_pcs_sub_geno <- y1_pcs_sub[rownames(genosub), ]
dim(y1_pcs_sub_geno) #131

#check order of info to be combined
identical(rownames(y1_pdata_sub_geno), rownames(genosub)) # TRUE
identical(rownames(covariates_nameans_geno), rownames(genosub)) # TRUE
identical(rownames(child_fscbc_ecc2_y1_df_sub_geno), rownames(genosub)) # TRUE
identical(rownames(y1_pcs_sub_geno), rownames(genosub)) # TRUE


#rename run and row vars of pdata
y1_pdata_sub_geno$run <- as.factor(y1_pdata_sub_geno$Run)
y1_pdata_sub_geno$row <- substr(y1_pdata_sub_geno$Sentrix_Position, 1, 3)
y1_pdata_sub_geno$row <- as.numeric(as.factor(y1_pdata_sub_geno$row))


#combine data frames together
covariates_nameans_geno_ctpc_tech <- cbind(covariates_nameans_geno,
                                           genosub,
                                           y1_pcs_sub_geno,
                                           y1_pdata_sub_geno[,c("run","row")])

#check size
dim(covariates_nameans_geno_ctpc_tech) #131 131
```

Select complete cases for age one time point.
```{r completecases}
covariates_nameans_geno_ctpc_tech_cc <- 
  covariates_nameans_geno_ctpc_tech[
    complete.cases(covariates_nameans_geno_ctpc_tech[,c("no2_preg_entire",
                                                                 "no2_y1_entire",
                                                                 "sex",
                                                                 "prenatal_maternal_smoking",
                                                                 "maternal_smoking_y1",
                                                                 "pss_18wk", "pss_6mos",
                                                                 "csed_18wk", "csed_6mos",
                                                                 "maternal_education_length")]),]
dim(covariates_nameans_geno_ctpc_tech_cc) #97 131

```

## Correlation heatmap between age one 97

Create function to calculate correlation coefficient between covariates. 
```{r cor2.function}

cor2 = function(df){
  
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  cor_fun <- function(pos_1, pos_2){
    
    # both are numeric
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
      print("both are numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      r <- stats::cor(df[[pos_1]], df[[pos_2]], use = "pairwise.complete.obs") #pairwise.complete.obs
      p <- unname((summary(lm(df[[pos_1]] ~ df[[pos_2]]))$coefficients[,4])[2])
      
    }
    
    #one is numberic the other is factor/character
    #must use sum of squares type 3 because groups are not of the same size
    #calculates ANOVA
    #then calcualtes eta-squared: measures the proportion of the total variance in a      dependent variable that
    #is associated with the membership of different groups defined by an independent      variable.
    #takes square root to get correlation
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        r <- 999
      } else {
        #anova for correlation
        r <- stats::aov(df[[pos_1]] ~ as.factor(df[[pos_2]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
        
        #anova for p-pval
        lm_p <- lm(df[[pos_1]] ~ as.factor(df[[pos_2]]))
        p <- (anova(lm_p))$`Pr(>F)`[1]
        
      }
      rm(tmp,tmp2)
    }
    
    
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        r <- stats::aov(df[[pos_2]] ~ as.factor(df[[pos_1]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
        
        #anova for p-pval
        lm_p <- lm(df[[pos_2]] ~ as.factor(df[[pos_1]]))
        p <- (anova(lm_p))$`Pr(>F)`[1]
        
      }
      rm(tmp,tmp2)
    }
    
    
  
    #both are factor/character
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
          r <-999
        } else { 
          r <- lsr::cramersV(df[[pos_1]], df[[pos_2]], simulate.p.value = TRUE)
          #get p value
          fish_table <- table(df[[pos_1]], df[[pos_2]])
          p <- fisher.test(fish_table, simulate.p.value=T)$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    return(r)
  } 
  
  cor_fun <- Vectorize(cor_fun)
  
  # now compute corr matrix
  corrmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) cor_fun(x, y)
  )
  
  rownames(corrmat) <- colnames(df)
  colnames(corrmat) <- colnames(df)
  return(corrmat)
}
```



Function to calculate pvalues of correlations between covariates.
```{r pval2.function}

pval2 = function(df){
  
  #check that classes are appropriate
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  
  ##################################
  #function for calculating pvalues#
  ##################################
  
  pval_fun <- function(pos_1, pos_2){
    

    ##################
    #both are numeric#
    ##################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
        
      print("both are numeric")
      
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        #dont want to star comparisons of something against itsself
        p <- 1
      } else {
        print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
        p <- unname((summary(lm(df[[pos_1]] ~ df[[pos_2]]))$coefficients[,4])[2])
      }
    }
  
    ########################################
    #first is integer and second is numeric#
    ########################################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        p <- 999
      } else {
       if(nlevels(droplevels(tmp2[,2]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_1]] ~ as.factor(df[[pos_2]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_1]] ~ as.factor(df[[pos_2]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ########################################
    #second is integer and first is numeric#
    ########################################
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        p <- 999
      } else {
        if(nlevels(droplevels(tmp2[,1]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_2]] ~ as.factor(df[[pos_1]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_2]] ~ as.factor(df[[pos_1]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ###########################
    #both are factor/character#
    ###########################
    
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        p <- 1
      } else {
        if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
          p <- 999
        } else {
          if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
            p <- 999
          } else {
            #get p value
            fish_table <- table(df[[pos_1]], df[[pos_2]])
            p <- fisher.test(fish_table, simulate.p.value = T)$p.value
          }
        }
      }
      rm(tmp,tmp2)
    }
    return(p)
  } 
  
  pval_fun <- Vectorize(pval_fun)
  
  # now compute corr matrix
  pvalmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) pval_fun(x, y)
  )
  
  rownames(pvalmat) <- colnames(df)
  colnames(pvalmat) <- colnames(df)
  return(pvalmat)
}
```


Get pvalues for correlations on a subset of covariates of interest.
```{r get-pvals}
covariates_nameans_geno_ctpc_tech_cc_sub <- 
  subset(covariates_nameans_geno_ctpc_tech_cc, 
                                   select=c(no2_y1_entire, 
                                            maternal_smoking_y1, 
                                            sex, 
                                            pss_6mos,
                                            csed_6mos, 
                                            maternal_education_length,
                                            y1.PC1, y1.PC2, y1.PC3,
                                            y1.PC4, y1.PC5, 
                                            genotyping.PC1, genotyping.PC2,
                                            genotyping.PC3,
                                            run, row, 
                                            studycentre))

#pvals calcs
covariates_nameans_geno_ctpc_tech_cc_sub_pval <- pval2(covariates_nameans_geno_ctpc_tech_cc_sub)
```


Calculate correlations between metadata variables using cor2 function above.  
```{r calc_covariate_corr}
#correlation calcs
covariates_nameans_geno_ctpc_tech_cc_sub_corr <- cor2(covariates_nameans_geno_ctpc_tech_cc_sub)

#set missing values (999) to NA - could have probably done this in the cor2 function
covariates_nameans_geno_ctpc_tech_cc_sub_corr[covariates_nameans_geno_ctpc_tech_cc_sub_corr == 999] <- NA
```



Modify ggcorrplot function to not blank out insignificant values
```{r func_mod}

#+++++++++++++++++++++++
# Helper Functions
#+++++++++++++++++++++++

# Get lower triangle of the correlation matrix
.get_lower_tri <- function(cormat, show.diag = FALSE) {
  if (is.null(cormat)) {
    return(cormat)
  }
  cormat[upper.tri(cormat)] <- NA
  if (!show.diag) {
    diag(cormat) <- NA
  }
  return(cormat)
}

# Get upper triangle of the correlation matrix
.get_upper_tri <- function(cormat, show.diag = FALSE) {
  if (is.null(cormat)) {
    return(cormat)
  }
  cormat[lower.tri(cormat)] <- NA
  if (!show.diag) {
    diag(cormat) <- NA
  }
  return(cormat)
}

.remove_diag <- function(cormat){
  if (is.null(cormat)) {
    return(cormat)
  }
  diag(cormat) <- NA
  cormat
}
# hc.order correlation matrix
.hc_cormat_order <- function(cormat, hc.method = "complete") {
  dd <- stats::as.dist((1 - cormat) / 2)
  hc <- stats::hclust(dd, method = hc.method)
  hc$order
}

.no_panel <- function() {
  ggplot2::theme(
    axis.title.x = ggplot2::element_blank(),
    axis.title.y = ggplot2::element_blank()
  )
}


# Convert a tbl to matrix
.tibble_to_matrix <- function(x){
  x <-  as.data.frame(x)
  rownames(x) <- x[, 1]
  x <- x[, -1]
  as.matrix(x)
}



corrplot <-
  
function (corr, method = c("square", "circle"), type = c("full", 
    "lower", "upper"), ggtheme = ggplot2::theme_minimal, 
    title = "", show.legend = TRUE, legend.title = "Corr", 
    show.diag = FALSE, colors = c("blue", "white", 
        "red"), outline.color = "gray", hc.order = FALSE, 
    hc.method = "complete", lab = FALSE, lab_col = "black", 
    lab_size = 4, p.mat = NULL, sig.level = 0.05, insig = c("pch", 
        "blank"), pch = 4, pch.col = "black", pch.cex = 5, 
    tl.cex = 12, tl.col = "black", tl.srt = 45, digits = 2) {
  
    type <- match.arg(type)
    method <- match.arg(method)
    insig <- match.arg(insig)
    if (inherits(corr, "cor_mat")) {
        cor.mat <- corr
        corr <- .tibble_to_matrix(cor.mat)
        p.mat <- .tibble_to_matrix(attr(cor.mat, "pvalue"))
    }
    if (!is.matrix(corr) & !is.data.frame(corr)) {
        stop("Need a matrix or data frame!")
    }
    corr <- as.matrix(corr)
    corr <- base::round(x = corr, digits = digits)
    if (hc.order) {
        ord <- .hc_cormat_order(corr)
        corr <- corr[ord, ord]
        if (!is.null(p.mat)) {
            p.mat <- p.mat[ord, ord]
            p.mat <- base::round(x = p.mat, digits = digits)
        }
    }
    if (type == "lower") {
        corr <- .get_lower_tri(corr, show.diag)
        p.mat <- .get_lower_tri(p.mat, show.diag)
    }
    else if (type == "upper") {
        corr <- .get_upper_tri(corr, show.diag)
        p.mat <- .get_upper_tri(p.mat, show.diag)
    }
    
    corr <- reshape2::melt(corr, na.rm = TRUE)
    colnames(corr) <- c("Var1", "Var2", "value")
    corr$pvalue <- rep(NA, nrow(corr))
    corr$signif <- rep(NA, nrow(corr))
    
    
    if (!is.null(p.mat)) {
        p.mat <- reshape2::melt(p.mat, na.rm = TRUE)
        corr$coef <- corr$value
        corr$pvalue <- p.mat$value
        corr$signif <- as.numeric(p.mat$value <= sig.level)
        
        #DONT GET RID OF STUFF BASED ON PVALUE
        #p.mat <- subset(p.mat, p.mat$value > sig.level)
        #if (insig == "blank") {
        #    corr$value <- corr$value * corr$signif
        }
    
    

    corr$abs_corr <- abs(corr$value) * 10
    p <- ggplot2::ggplot(data = corr, 
                         mapping = ggplot2::aes_string(x = "Var1",
                                                       y = "Var2", 
                                                       fill = "value"))
    
    if (method == "square") {
        p <- p + ggplot2::geom_tile(color = outline.color)
    } else if (method == "circle") {
      p <- p + ggplot2::geom_point(color = outline.color, shape = 21, 
                                   ggplot2::aes_string(size = "abs_corr")) + 
        ggplot2::scale_size(range = c(4,10)) + 
        ggplot2::guides(size = FALSE)
    }
    
    
    p <- p + ggplot2::scale_fill_gradient2(low = colors[1],
                                           high = colors[3],
                                           mid = colors[2], 
                                           midpoint = 0, 
                                           limit = c(-1, 1), 
                                           space = "Lab", 
                                           name = "Correlation coefficient")
    
    
    if (class(ggtheme)[[1]] == "function") {
        p <- p + ggtheme()
    } else if (class(ggtheme)[[1]] == "theme") {
        p <- p + ggtheme
    }
    
    p <- p + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = tl.srt,
                                                                vjust = 1,
                                                                size = tl.cex,
                                                                hjust = 1), 
                            axis.text.y = ggplot2::element_text(size = tl.cex)) + 
      ggplot2::coord_fixed()
    
    
    #LABEL WITH PVALUE NOT CORRELATION COEFFICIENT
    label <- round(x = corr[, "signif"], digits = digits)
    
    
    if (!is.null(p.mat) & insig == "blank") {
        ns <- corr$pvalue > sig.level
        if (sum(ns) > 0) 
            label[ns] <- " "
    }
    
    if (lab) {
        #p <- p + ggplot2::geom_text(mapping = ggplot2::aes_string(x = "Var1", 
        #    y = "Var2"), label = label , color = lab_col, 
        #    size = lab_size)
        
        p <- p + ggplot2::geom_point(data = corr %>% subset(signif==1),
                                     mapping = ggplot2::aes_string(x = "Var1", y = "Var2"), 
                                     shape = pch, size = pch.cex, color = pch.col)
        
    }
    
    if (!is.null(p.mat) & insig == "pch") {
        p <- p + ggplot2::geom_point(data = p.mat,
                                     mapping = ggplot2::aes_string(x = "Var1", y = "Var2"), 
                                     shape = pch, size = pch.cex, color = pch.col)
    }
    if (title != "") {
        p <- p + ggplot2::ggtitle(title)
    }
    if (!show.legend) {
        p <- p + ggplot2::theme(legend.position = "none")
    }
    p <- p + .no_panel()
    corr_plot <<- p
    p
  }
```
  
  
```{r corrplot}
corrplot(covariates_nameans_geno_ctpc_tech_cc_sub_corr,
         pch = 8,
         pch.cex = 1.5,
         type = "lower", 
         p.mat = covariates_nameans_geno_ctpc_tech_cc_sub_pval,
         insig = "blank",
         lab=TRUE,
         tl.cex =6, 
         colors = c("#6D9EC1", "white", "#E46726")) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        legend.key.height = unit(0.5, 'cm'),
        legend.key.width = unit(0.2, 'cm'),
        legend.text = element_text(size=5),
        legend.title = element_text(size=7),
        legend.position="left") +
  scale_y_discrete(labels = c("Year one NO2", "Maternal smoking", "Sex", 
                              "Maternal stress", "Maternal depression",
                              "Maternal education length", 
                              "Cell type PC1", "Cell type PC2", "Cell type PC3",
                              "Cell type PC4", "Cell type PC5", 
                              "Genotyping PC1", "Genotyping PC2", "Genotyping PC3", 
                              "Run", "Row"),
                   position = "right") +
  scale_x_discrete(labels = c("Maternal smoking", "Sex", 
                              "Maternal stress", "Maternal depression",
                              "Maternal education length",
                              "Cell type PC1", "Cell type PC2", "Cell type PC3",
                              "Cell type PC4", "Cell type PC5", 
                              "Genotyping PC1", "Genotyping PC2", "Genotyping PC3",
                              "Run", "Row","Study centre")) 


ggsave(here("figures", "covariates", "2021-01-27_CHILD_ageone97_corrplot.tiff"),
       device="tiff",
       height=3,
       width=6,
       units="in")
```

