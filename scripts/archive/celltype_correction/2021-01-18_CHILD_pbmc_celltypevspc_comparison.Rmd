---
title: "CHILD PBMC cell types vs PCs correction"
author: "SL"
date: "19/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

IMPORTANT: This code is for cell type correction before linear models for EWAS. The other option is to include cell type proportions in EWAS linear models. 

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(minfi)
library(pbapply)
library(limma)
library(rgr) #for log centred ratio transfromation
library(factoextra)
library(GGally)
library(here)
```

Load preprocessed CHILD data.  
```{r load_betas, message=FALSE, warning=FALSE}
load("R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution/output_data/preprocessed_data/2021-01_14_CHILD_preprocessed_betas_pdata_annotation.Rdata")
```

Load CHILD145 deconvolution data. This deconvolution does not include granulocytes as granulocytes are not expected.
```{r load_deconvolution, message=FALSE, warning=FALSE}
load(here("output_data", "deconvolution", "2020-11-10_CBMC_PBMC_deconvolution.RData"))

#only want to keep child_fscbc_ecc2_y1
rm(child_fscbc_ecc2_cb)

#convert deconvolution data to dataframe
child_fscbc_ecc2_y1_df <- as.data.frame(child_fscbc_ecc2_y1$counts)
```

Subset out age one beta for cell type correction.  
```{r subset_betas}
#subset out cordblood samples from beta matrix
y1_betas <- betas[,colnames(betas) %in% rownames(subset(pdata_nodups, Tissue == "P"))]

#check size of mval matrix after subsetting
dim(y1_betas) #145
min(y1_betas) # 0.002962203
max(y1_betas) # 0.9981364
```


## Cell type correction

Correct age one PBMCs for cell type using linear regression. 

Based on "Adjusting for cell type composition in DNA methylation data using a regression-based approach" by Jones et al (2017).  

The data is composite data and cell types are not independent of one another:  

Two ways of dealing with this:  

1. Do a PCA  
* variables are not independent -PCA will give all the same data but in independent vectors  
* But cant do PCA on composite data - this is composite data  
* Do a centred log ratio before PCA to get around this  

2. Leave out one cell type  
* More simple way  
* Usually leave cell type that is largest proportion  
* For whole blood/cord blood - drop granulocytes  
* For PMBCs and CBMCs - drop CD4T cells  


Cell type correction
```{r cordblood_celltype_correction}
#fit a linear model for each probe in the matrix
#no granulocytes
#drop cd4t

#fit a linear model for each probe in the matrix using cell type PCs as covariates
y1_celltype_design <- model.matrix(~ NK + Bcell + Mono + CD8T ,
                              data=child_fscbc_ecc2_y1_df)

#fit methylation to batch variables then get residuals
y1_celltype_fit <-  lmFit(y1_betas, y1_celltype_design)

#get residuals 
y1_celltype_residuals <- residuals(y1_celltype_fit, y1_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(y1_celltype_residuals), colnames(y1_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
celltype_adj_betas <- y1_celltype_residuals + matrix(apply(y1_betas, 1, mean), 
                                     nrow=nrow(y1_celltype_residuals), 
                                     ncol=ncol(y1_celltype_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(y1_betas[1:5,1:5])
#cell type PC adjusted
print(celltype_adj_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(celltype_adj_betas) # 1.157661 
min(celltype_adj_betas) # -0.2376358

# adj.betas contains values less than 0 and greater than 1 
# These need to be fixed because they result in NAs during conversion to M values
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
message("Setting floor to lowest measurement above 0,\n",
        "and ceiling to highest measurement below 1 for M value conversion")
celltype_adj_betas[celltype_adj_betas > 1] <- max(celltype_adj_betas[celltype_adj_betas < 1])
celltype_adj_betas[celltype_adj_betas < 0] <- min(celltype_adj_betas[celltype_adj_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(celltype_adj_betas) # 0.999999
min(celltype_adj_betas) # 1.07643e-06

```


Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
celltype_adj_mvals <- lumi::beta2m(celltype_adj_betas)

#check max/min of mvals
max(celltype_adj_mvals)
min(celltype_adj_mvals)
```


## Now with PCs

Centred log ratio wont accept negative values. Additionally, centred log ratio will accept zeros however rows with 0s will return NA for 0 instance and infinity for all othe values. Therefore check for any negative values as well as 0s. If there are zeroes or negatives need to investigate why.
```{r remove_neg_values}
#check how many negatives
sum(child_fscbc_ecc2_y1_df <= 0) #0
```

Centred log ratio of estimated cell type proportions.
```{r clr}
y1_celltypes_clr <- clr(as.matrix(child_fscbc_ecc2_y1_df))

#check for NAs or inf
#these will occur if zeroes or negatives existed in cell tyoe estimates
sum(is.na(y1_celltypes_clr)) #0
sum(is.infinite(y1_celltypes_clr)) #0
```

Run PCA analysis on CLR transformed cell type estimates
```{r celltype_pca}
#pca
y1_pca <- prcomp(y1_celltypes_clr, scale. = TRUE)

#scree plot
factoextra::fviz_eig(y1_pca)

#convert to dataframe
y1_pcs <- as.data.frame(y1_pca$x)

#examine grouping of pcs
ggpairs(y1_pcs, columns=1:5, progress=FALSE)  
```


Cell type correction using the first 5 cell type PCs. 
```{r cordblood_5PC_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
y1_pcs_design <- model.matrix(~ PC1 + PC2 + PC3 + PC4 + PC5, data=y1_pcs)

#fit methylation to batch variables then get residuals
y1_pcs_fit <-  lmFit(y1_betas, y1_pcs_design)

#get residuals 
y1_pcs_residuals <- residuals(y1_pcs_fit, y1_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(y1_pcs_residuals), colnames(y1_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
pc_adj_betas <- y1_pcs_residuals + matrix(apply(y1_betas, 1, mean), 
                                     nrow=nrow(y1_pcs_residuals), 
                                     ncol=ncol(y1_pcs_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(y1_betas[1:5,1:5])
#cell type PC adjusted
print(pc_adj_betas[1:5,1:5])
```



Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(pc_adj_betas) #1.182634
min(pc_adj_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
pc_adj_betas[pc_adj_betas > 1] <- max(pc_adj_betas[pc_adj_betas < 1])
pc_adj_betas[pc_adj_betas < 0] <- min(pc_adj_betas[pc_adj_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(pc_adj_betas) # 0.9999994
min(pc_adj_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
pc_adj_mvals <- lumi::beta2m(pc_adj_betas)

#check max/min of mvals
max(pc_adj_mvals)
min(pc_adj_mvals)
```

Cell type correction using the first 4 cell type PCs. 
```{r cordblood_4PC_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
y1_4pcs_design <- model.matrix(~ PC1 + PC2 + PC3 + PC4 , data=y1_pcs)

#fit methylation to batch variables then get residuals
y1_4pcs_fit <-  lmFit(y1_betas, y1_4pcs_design)

#get residuals 
y1_4pcs_residuals <- residuals(y1_4pcs_fit, y1_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(y1_4pcs_residuals), colnames(y1_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
pc4_adj_betas <- y1_4pcs_residuals + matrix(apply(y1_betas, 1, mean), 
                                     nrow=nrow(y1_4pcs_residuals), 
                                     ncol=ncol(y1_4pcs_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(y1_betas[1:5,1:5])
#cell type PC adjusted
print(pc4_adj_betas[1:5,1:5])
```



Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(pc4_adj_betas) #1.182634
min(pc4_adj_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
pc4_adj_betas[pc4_adj_betas > 1] <- max(pc4_adj_betas[pc4_adj_betas < 1])
pc4_adj_betas[pc4_adj_betas < 0] <- min(pc4_adj_betas[pc4_adj_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(pc4_adj_betas) # 0.9999994
min(pc4_adj_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
pc4_adj_mvals <- lumi::beta2m(pc4_adj_betas)

#check max/min of mvals
max(pc4_adj_mvals)
min(pc4_adj_mvals)
```






### Heat scree plots for comparing correction efficiency


Set up heat scree plot function
```{r heat_plot}

#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot <- function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Rename rownames accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}

```




```{r model_matrix_age1}
#subset out cordblood meta data 
y1_pdata <- as.data.frame(subset(pdata_nodups, Tissue == "P"))

#change categorical variables to factors
y1_pdata$Run <- as.factor(y1_pdata$Run)
y1_pdata$Chip <- as.factor(y1_pdata$Sentrix_ID)
#pull out row from sentrix position then set to factor
y1_pdata$Row <- substr(y1_pdata$Sentrix_Position, 1, 3)
y1_pdata$Row <- as.factor(y1_pdata$Row)
y1_pdata$Row <- as.numeric(y1_pdata$Row)
y1_pdata$Sex <- as.factor(y1_pdata$Sex)
y1_pdata$Group <- as.factor(y1_pdata$Group)
y1_pdata$Atopy <- as.factor(y1_pdata$Atopy)
y1_pdata$Wheeze <- as.factor(y1_pdata$Wheeze)

#check to see if samples are in same order between pData and and betas
identical(rownames(y1_pdata), rownames(child_fscbc_ecc2_y1_df))
#bind columns together for one large metadata frame
y1_pdata <- cbind(y1_pdata, child_fscbc_ecc2_y1_df)


#create a model matrix using pData
#this generates intercepts only since we are not adding in covariates
mod = model.matrix(~1, data=y1_pdata)
```

```{r heatscree_before}
#convert raw betas to mvals
y1_mvals <- lumi::beta2m(y1_betas)
max(y1_mvals)
min(y1_mvals)

#pca 
uncor.dat <- t(scale(t(y1_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata[,c("Sex", "Group", "Run", "Chip")] 
meta_continuous <- y1_pdata[,c("NK", "Bcell", "Mono", "CD8T", "CD4T", "Row")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


PCs after cell type correction
```{r heatscree_celltype}
#pca 
uncor.dat <- t(scale(t(celltype_adj_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata[,c("Sex", "Group", "Run", "Chip")] 
meta_continuous <- y1_pdata[,c("NK", "Bcell", "Mono", "CD8T", "CD4T", "Row")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```

PCs after 5 PC correction
```{r heatscree_pc}
#pca 
uncor.dat <- t(scale(t(pc_adj_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata[,c("Sex", "Group", "Run", "Chip")] 
meta_continuous <- y1_pdata[,c("NK", "Bcell", "Mono", "CD8T", "CD4T", "Row")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


PCs afte 4 PC correction
```{r heatscree_pc}
#pca 
uncor.dat <- t(scale(t(pc4_adj_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata[,c("Sex", "Group", "Run", "Chip")] 
meta_continuous <- y1_pdata[,c("NK", "Bcell", "Mono", "CD8T", "CD4T", "Row")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```