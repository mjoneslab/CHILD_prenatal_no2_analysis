---
title: "CHILD cord blood cell type correciton"
author: "SL"
date: "December 14, 2020"
output: html_document
---

*IMPORTANT*: This code is for cell type correction before linear models for EWAS. The other option is to include cell type proportions in EWAS linear models. As CHILD is a relatively small cohort (and we lose many participants to missing data), correcting for cell type before linear models can improve power to detect DNAm changes. When cohorts are larger (and better powered), it is more correct to include cell types (or cell type PCs) in final linear model. 


```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(tidyverse)
library(minfi)
library(here)
library(pbapply)
```

Load preprocessed CHILD data.  
```{r load_CHILD_data, message=FALSE, warning=FALSE}
load(here("output_data", "preprocessed_data", "2020-11_19_CHILD_preprocessed_betas_pdata_annotation.Rdata"))
```

Load deconvolution data.
```{r load_CHILD_data, message=FALSE, warning=FALSE}
load("R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution/output_data/deconvolution/2020-11-10_CBMC_PBMC_deconvolution.Rdata")
```


## Cord blood data prepartion for cell type correction 

Subset out cord blood betas for cell type correction.  
```{r subset_cordblood_betas}
#subset out cordblood samples from beta matrix
cb_betas <- betas[,colnames(betas) %in% rownames(subset(pdata_nodups, Tissue == "C"))]

#check size of mval matrix after subsetting
#also check min max to confirm these are beta values
#want touse betas for linear model to prevent weird compresion of mvals
dim(cb_betas) #144
min(cb_betas) #0.002973941
max(cb_betas) #0.9980669
```


Remove duplicates from cord blood deconvolution data.  
```{r remove_dups_from_deconvo}
#convert deconvolution data to dataframe
child_fscbc_ecc2_cb_df <- as.data.frame(child_fscbc_ecc2_cb$counts)

#make list of samples to remove from beta and pData
dups_rm <-c("9298768102_R06C01", "9341679111_R05C02", "9298768023_R03C02",
            "9341679076_R06C02", "9297962089_R06C02", "9298768023_R02C02",
            "9341679097_R02C02", "9341679114_R01C02", "9298768023_R06C01")

#remove replicates from pData                        
child_fscbc_ecc2_cb_df_nodups <-
  child_fscbc_ecc2_cb_df[!rownames(child_fscbc_ecc2_cb_df) %in% dups_rm, ]

#check that 9 samples were removed
dim(child_fscbc_ecc2_cb_df_nodups) #144
dim(child_fscbc_ecc2_cb_df) #153

#check that naming is identical
identical(rownames(child_fscbc_ecc2_cb_df_nodups), colnames(cb_betas)) #true
```



## Cell type correction

Correct cordblood for cell type using linear regression. 

Based on "Adjusting for cell type composition in DNA methylation data using a regression-based approach" by Jones et al (2017).  

The data is composite data and cell types are not independent of one another:  

Two ways of dealing with this:  

1. Do a PCA  
* variables are not independent -PCA will give all the same data but in independent vectors  
* But cant do PCA on composite data - this is composite data  
* Do a centred log ratio before PCA to get around this  

2. Leave out one cell type  
* More simple way  
* Usually leave cell type that is largest proportion  
* For whole blood/cord blood - drop granulocytes  
* For PMBCs and CBMCs - drop CD4T cells  


Repeat cell type correction this time leaving out one cell tye
```{r cordblood_celltype_correction_NOCD4T}
#fit a linear model for each probe in the matrix
#no granulocytes
#drop cd4t

#lead out CD4T in linear model to prevent overfitting
#this is because cell type predictions are not perfect

cb_betas_lm <- pbapply(cb_betas, 1, function(x) 
  {
  cordblood <- child_fscbc_ecc2_cb_df_nodups[colnames(cb_betas),]
  lm(x ~ NK + nRBC + Bcell + Mono + CD8T, data=cordblood, x=TRUE, na.action = NULL)
  })



#extract a matrix of residuals from the cordblood linear models (cb_betaslm)
#residuals = observed methylation values - predicted methylation value from linear model
#residuals represent variability that is not explained by cell type comp 
#cb_residuals = residuals from linear model
#residuals = residuals calcualted in linear model
cb_residuals <- t(pbsapply(cb_betas_lm, function(x) residuals(summary(x))))


#check if colnames of cordblood residuals and cord blood beta are the same
identical(colnames(cb_residuals), colnames(cb_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
adj_cb_betas <- cb_residuals + matrix(apply(cb_betas, 1, mean), 
                                     nrow=nrow(cb_residuals), 
                                     ncol=ncol(cb_residuals))

#check how unadjusted and adjusted betas compares
#unadjusted
print(cb_betas[1:5,1:5])
#adjusted
print(adj_cb_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(adj_cb_betas) #1.16
min(adj_cb_betas) #-0.18

# adj.betas contains values less than 0 and greater than 1 (this is nikho's code!)
# These need to be fixed because they result in NAs during conversion to M values
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
message("Setting floor to lowest measurement above 0,\n",
        "and ceiling to highest measurement below 1 for M value conversion")
adj_cb_betas[adj_cb_betas > 1] <- max(adj_cb_betas[adj_cb_betas < 1])
adj_cb_betas[adj_cb_betas < 0] <- min(adj_cb_betas[adj_cb_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(adj_cb_betas) # 0.9999997
min(adj_cb_betas) # 2.688483e-06

```


Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
adj_cb_mvals <- lumi::beta2m(adj_cb_betas)

#check max/min of mvals
max(adj_cb_mvals)
min(adj_cb_mvals)
```



Set up heat scree plot function
```{r heat_plot}

#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot <- function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Rename rownames accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}

```

```{r model_matrix_cordblood}
#subset out cordblood meta data 
cb_pdata <- as.data.frame(subset(pdata_nodups, Tissue == "C"))
#remove tissue column since no longer provides any info
cb_pdata <- subset(cb_pdata, select= -(Tissue))

#change categorical variables to factors
cb_pdata$Run <- as.factor(cb_pdata$Run)
cb_pdata$Sentrix_ID <- as.factor(cb_pdata$Sentrix_ID)
#pull out row from sentrix position then set to factor
cb_pdata$row <- substr(cb_pdata$Sentrix_Position, 1, 3)
cb_pdata$row <- as.factor(cb_pdata$row)
cb_pdata$Sex <- as.factor(cb_pdata$Sex)
cb_pdata$Group <- as.factor(cb_pdata$Group)
cb_pdata$Atopy <- as.factor(cb_pdata$Atopy)
cb_pdata$Wheeze <- as.factor(cb_pdata$Wheeze)

#check to see if samples are in same order between pData and and betas
identical(rownames(cb_pdata), rownames(child_fscbc_ecc2_cb_df_nodups))
#bind columns together for one large metadata frame
cb_pdata <- cbind(cb_pdata, child_fscbc_ecc2_cb_df_nodups)


#create a model matrix using pData
#this generates intercepts only since we are not adding in covariates
mod = model.matrix(~1, data=cb_pdata)
```

```{r heatscree_after_correction}
uncor.dat <- t(scale(t(adj_cb_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- cb_pdata[,c("Sex", "Group")] 
meta_continuous <- cb_pdata[,c("NK", "nRBC", "Bcell", "Mono", "CD8T", "CD4T")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```

PCs before cell type correction
```{r heatscree_before_correction}
#convert unadjusted betas to mvals for pc heat scree
cb_mvals <- lumi::beta2m(cb_betas)

#heat scree
uncor.dat <- t(scale(t(cb_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- cb_pdata[,c("Sex", "Group")] 
meta_continuous <- cb_pdata[,c("NK", "nRBC", "Bcell", "Mono", "CD8T", "CD4T")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```



Save adjusted cord blood beta matrix
```{r save_adjusted_betas}
save(adj_cb_betas, pdata_nodups, annotation,
     file = here("output_data", "celltype_corrected_betas", "2020-12-14_CHILD_birth_betas_celltype_corrected.Rdata"))
```
 







