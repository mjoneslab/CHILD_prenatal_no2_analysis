---
title: "CHILD CBMC and age one PBMC deconvolution"
author: "SL"
date: "2020-10-27"
output: html_document
---

*Purpose*: Cell type deconvolution allows prediction of cell type proportions in cordblood and PMBCs. Cell type proprotions are corrected for in later analysis. 

*NB*: For deconvolution using estimateCellCounts2 or estimateCellCounts must use RGset (estimateCellCounts2 allows mset but functionality is reduced). CHILD rgset_no_badsamp_probe_lowbead has bad samples removed. Bad probes, cross reactive probes, xy probes, and SNP probes have not yet been removed. 

Load required libraries
```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(sva)
library(minfi)
library(ExperimentHub)
library(FlowSorted.Blood.EPIC)
library(FlowSorted.Blood.450k)
library(FlowSorted.CordBloodCombined.450k)
library(FlowSorted.CordBlood.450k)
library(here)

#for some reason flowsorted.cordbloodcombined.450k.compTable is only found if all above libraries are loaded - shouldnt need blood.450k and cordblood.450k
```


Load rgset_no_badsamp_probe_lowbead for deconvolution comparison.  
```{r load_rgset}
load(here("output_data", "preprocessed_data", "2020-11-10_child_rgset_nobadsamp.Rdata"))
```


Separate cordblood (CMBCs) and year 1 PMBCs.
```{r separate_tissues}
#correct sample mix up 
#sample mix up was determined in preprocessing and analysis after rgset_no_badsamp_probe_lowbead was generated
#tissue mix up for sample 20113 -> relabel
rgset_nobadsamp$SampleID[5] <- "20113_P"
rgset_nobadsamp$Tissue[5] <- "P"
rgset_nobadsamp$SampleID[6] <- "20113_C"
rgset_nobadsamp$Tissue[6] <- "C"


#cord blood 
cb_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="C"]
dim(cb_rgset)

#year 1 pmbcs
y1_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="P"]
dim(y1_rgset)
```

Change estimateCellCounts2 and its internal function pickCompProbes to output probes used for deconvolution.
```{r estimatecellcounts2_pickcompprobes}

#################
#pickCompProbes2#
#################

pickCompProbes2 <- 
  function(mSet, cellTypes = NULL, numProbes = 50, 
                            compositeCellType = compositeCellType, 
                            probeSelect = probeSelect) {
    p <- getBeta(mSet)
    pd <- as.data.frame(colData(mSet))
    if(!is.null(cellTypes)) {
        if(!all(cellTypes %in% pd$CellType))
            stop(strwrap("elements of argument 'cellTypes' are not part of 
                        'mSet$CellType'", width = 80, prefix = " ", 
                        initial = ""))
        keep <- which(pd$CellType %in% cellTypes)
        pd <- pd[keep,]
        p <- p[,keep]
    }
    ## make cell type a factor 
    pd$CellType <- factor(pd$CellType, levels = cellTypes)
    ffComp <- rowFtests(p, pd$CellType)
    tIndexes <- split(seq(along=pd$CellType), pd$CellType)
    prof <- vapply(tIndexes, function(i) rowMeans(p[,i]), 
                    FUN.VALUE=numeric(dim(p)[1]))
    r <- rowRanges(p)
    compTable <- cbind(ffComp, prof, r, abs(r[,1] - r[,2]))
    names(compTable)[1] <- "Fstat"
    names(compTable)[c(-2,-1,0) + ncol(compTable)] <- c("low", "high", "range") 
    tstatList <- lapply(tIndexes, function(i) {
        x <- rep(0,ncol(p))
        x[i] <- 1
        return(rowttests(p, factor(x)))
    })
    if (probeSelect == "any"){
        probeList <- lapply(tstatList, function(x) {
            y <- x[x[,"p.value"] < 1e-8,]
            yAny <- y[order(abs(y[,"dm"]), decreasing=TRUE),]      
            c(rownames(yAny)[seq_len(numProbes*2)])
        })
        #output all picked probes
        probelist_all <<- probelist
    } else {
        probeList <- lapply(tstatList, function(x) {
            y <- x[x[,"p.value"] < 1e-8,]
            yUp <- y[order(y[,"dm"], decreasing=TRUE),]
            yDown <- y[order(y[,"dm"], decreasing=FALSE),]
            c(rownames(yUp)[seq_len(numProbes)], 
                rownames(yDown)[seq_len(numProbes)])
        })
        #output all picked probes
        probelist_all <<- probelist
    }
    trainingProbes <- unique(unlist(probeList))
    p <- p[trainingProbes,]
    
    pMeans <- colMeans(p)
    names(pMeans) <- pd$CellType
    form <- as.formula(sprintf("y ~ %s - 1", paste(levels(pd$CellType), 
                                                    collapse="+")))
    phenoDF <- as.data.frame(model.matrix(~pd$CellType-1))
    colnames(phenoDF) <- sub("^pd\\$CellType", "", colnames(phenoDF))
    if(ncol(phenoDF) == 2) { # two group solution
        X <- as.matrix(phenoDF)
        coefEsts <- t(solve(t(X) %*% X) %*% t(X) %*% t(p))
    } else { # > 2 group solution
        tmp <- validationCellType(Y = p, pheno = phenoDF, modelFix = form)
        coefEsts <- tmp$coefEsts
    }
    
    out <- list(coefEsts = coefEsts, compTable = compTable,
                sampleMeans = pMeans)
    return(out)
}

###########################
#estimateCellCounts2Probes#
###########################

estimateCellCounts2probes <- 
function (rgSet, compositeCellType = "Blood", processMethod = "preprocessNoob", 
    probeSelect = c("auto", "any", "IDOL"), 
    cellTypes = c("CD8T", "CD4T", "NK", "Bcell", 
        "Mono", "Neu"), referencePlatform = c("IlluminaHumanMethylation450k", 
        "IlluminaHumanMethylationEPIC", "IlluminaHumanMethylation27k"), 
    referenceset = NULL, IDOLOptimizedCpGs = NULL, returnAll = FALSE, 
    meanPlot = FALSE, verbose = TRUE, lessThanOne = FALSE, ...) 
{
    if ((!is(rgSet, "RGChannelSet")) && (!is(rgSet, "MethylSet"))) 
        stop(strwrap(sprintf("object is of class '%s', but needs to be of \n                                class 'RGChannelSet' 'RGChannelSetExtended' or \n                                'MethylSet' to use this function", 
            class(rgSet)), width = 80, prefix = " ", initial = ""))
    if (!is(rgSet, "RGChannelSet") && (processMethod[1] != 
        "preprocessQuantile")) 
        stop(strwrap(sprintf("object is of class '%s', but needs to be of \n                                class 'RGChannelSet' or 'RGChannelSetExtended' \n                                to use other methods different to \n                                'preprocessQuantile'", 
            class(rgSet)), width = 80, prefix = " ", initial = ""))
    if (is(rgSet, "MethylSet") && (processMethod[1] == 
        "preprocessQuantile")) 
        message(strwrap("[estimateCellCounts2] The function will assume that\n                            no preprocessing has been performed. Using \n                            'preprocessQuantile' in prenormalized data is \n                            experimental and it should only be run under the \n                            user responsibility", 
            width = 80, prefix = " ", initial = ""))
    if (is(rgSet, "RGChannelSetExtended")) 
        rgSet <- as(rgSet, "RGChannelSet")
    referencePlatform <- match.arg(referencePlatform)
    rgPlatform <- sub("IlluminaHumanMethylation", "", 
        annotation(rgSet)[which(names(annotation(rgSet)) == "array")])
    platform <- sub("IlluminaHumanMethylation", "", 
        referencePlatform)
    if ((compositeCellType == "CordBlood" | compositeCellType == 
        "CordBloodCombined") && (!"nRBC" %in% cellTypes)) 
        message(strwrap("[estimateCellCounts2] Consider including 'nRBC' in \n                        argument 'cellTypes' for cord blood estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if ((compositeCellType == "Blood") && (referencePlatform == 
        "IlluminaHumanMethylationEPIC") && ("Gran" %in% 
        cellTypes)) 
        message(strwrap("[estimateCellCounts2] Replace 'Gran' for 'Neu' in \n                        argument 'cellTypes' for EPIC blood estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if ((compositeCellType != "Blood") && ("Neu" %in% 
        cellTypes)) 
        message(strwrap("[estimateCellCounts2] Check whether 'Gran' or 'Neu' is \n                        present in your reference and adjust argument \n                        'cellTypes' for your estimation.\n", 
            width = 80, prefix = " ", initial = ""))
    if (compositeCellType == "CordBloodCombined") 
        platform <= "450k"
    referencePkg <- sprintf("FlowSorted.%s.%s", compositeCellType, 
        platform)
    subverbose <- max(as.integer(verbose) - 1L, 0L)
    if (!is.null(referenceset)) {
        referenceRGset <- get(referenceset)
        if (!is(rgSet, "RGChannelSet")) 
            referenceRGset <- preprocessRaw(referenceRGset)
    }
    else {
        if (!require(referencePkg, character.only = TRUE)) 
            stop(strwrap(sprintf("Could not find reference data package for \n                                compositeCellType '%s' and referencePlatform \n                                '%s' (inferred package name is '%s')", 
                compositeCellType, platform, referencePkg), width = 80, 
                prefix = " ", initial = ""))
        if ((referencePkg != "FlowSorted.Blood.EPIC") && 
            (referencePkg != "FlowSorted.CordBloodCombined.450k")) {
            referenceRGset <- get(referencePkg)
        }
        else if (referencePkg == "FlowSorted.Blood.EPIC") {
            hub <- ExperimentHub()
            referenceRGset <- hub[["EH1136"]]
        }
        else if (referencePkg == "FlowSorted.CordBloodCombined.450k") {
            hub <- ExperimentHub()
            referenceRGset <- hub[["EH2256"]]
        }
        if (!is(rgSet, "RGChannelSet")) 
            referenceRGset <- preprocessRaw(referenceRGset)
    }
    if (rgPlatform != platform) {
        rgSet <- convertArray(rgSet, outType = referencePlatform, 
            verbose = TRUE)
    }
    if (!"CellType" %in% names(colData(referenceRGset))) 
        stop(strwrap(sprintf("the reference sorted dataset (in this case '%s') \n                            needs to have a phenoData column called \n                            'CellType'"), 
            names(referencePkg), width = 80, prefix = " ", 
            initial = ""))
    if (sum(colnames(rgSet) %in% colnames(referenceRGset)) > 
        0) 
        stop(strwrap("the sample/column names in the user set must not be in \n                    the reference data ", 
            width = 80, prefix = " ", initial = ""))
    if (!all(cellTypes %in% referenceRGset$CellType)) 
        stop(strwrap(sprintf("all elements of argument 'cellTypes' needs to be \n                            part of the reference phenoData columns 'CellType' \n                            (containg the following elements: '%s')", 
            paste(unique(referenceRGset$cellType), collapse = "', '")), 
            width = 80, prefix = " ", initial = ""))
    if (length(unique(cellTypes)) < 2) 
        stop("At least 2 cell types must be provided.")
    if ((processMethod == "auto") && (compositeCellType %in% 
        c("Blood", "DLPFC"))) 
        processMethod <- "preprocessQuantile"
    if ((processMethod == "auto") && (!compositeCellType %in% 
        c("Blood", "DLPFC")) && (is(rgSet, "RGChannelSet"))) 
        processMethod <- "preprocessNoob"
    processMethod <- get(processMethod)
    if ((probeSelect == "auto") && (compositeCellType %in% 
        c("CordBloodCombined", "CordBlood", "CordBloodNorway", 
            "CordTissueAndBlood"))) {
        probeSelect <- "any"
    }
    if ((probeSelect == "auto") && (!compositeCellType %in% 
        c("CordBloodCombined", "CordBlood", "CordBloodNorway", 
            "CordTissueAndBlood"))) {
        probeSelect <- "both"
    }
    if (verbose) 
        message(strwrap("[estimateCellCounts2] Combining user data with \n                        reference (flow sorted) data.\n", 
            width = 80, prefix = " ", initial = ""))
    newpd <- DataFrame(sampleNames = c(colnames(rgSet), colnames(referenceRGset)), 
        studyIndex = rep(c("user", "reference"), 
            times = c(ncol(rgSet), ncol(referenceRGset))))
    referenceRGset$CellType <- as.character(referenceRGset$CellType)
    if (is.null(rgSet$CellType)) 
        rgSet$CellType <- rep("NA", dim(rgSet)[2])
    if (is.null(rgSet$Age)) 
        rgSet$Age <- rep("NA", dim(rgSet)[2])
    if (is.null(rgSet$Sex)) 
        rgSet$Sex <- rep("NA", dim(rgSet)[2])
    if (is.null(referenceRGset$Sex)) {
        referenceRGset$Sex <- rep("NA", dim(referenceRGset)[2])
    }
    else {
        referenceRGset$Sex <- as.character(referenceRGset$Sex)
    }
    if (is.null(referenceRGset$Age)) {
        referenceRGset$Age <- rep("NA", dim(referenceRGset)[2])
    }
    else {
        try(referenceRGset$Age <- as.numeric(referenceRGset$Age))
    }
    commoncolumn <- intersect(names(colData(rgSet)), names(colData(referenceRGset)))
    restry <- try({
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }, silent = TRUE)
    if ("try-error" %in% class(restry)) {
        commoncolumn <- c("CellType", "Sex", "Age")
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }
    else {
        colData(rgSet)[commoncolumn] <- mapply(FUN = as, colData(rgSet)[commoncolumn], 
            vapply(colData(referenceRGset)[commoncolumn], class, 
                FUN.VALUE = character(1)), SIMPLIFY = FALSE)
    }
    rm(restry)
    colData(referenceRGset) <- colData(referenceRGset)[commoncolumn]
    colData(rgSet) <- colData(rgSet)[commoncolumn]
    referencePd <- colData(referenceRGset)
    combinedRGset <- combineArrays(rgSet, referenceRGset, outType = referencePlatform)
    colData(combinedRGset) <- newpd
    colnames(combinedRGset) <- newpd$sampleNames
    rm(referenceRGset)
    if (verbose) 
        message(strwrap("[estimateCellCounts2] Processing user and reference \n                        data together.\n", 
            width = 80, prefix = " ", initial = ""))
    if (compositeCellType == "CordBlood") {
        if (!is(combinedRGset, "RGChannelSet")) 
            combinedRGset@preprocessMethod["rg.norm"] <- "Raw (no normalization or bg correction)"
        combinedMset <- processMethod(combinedRGset, verbose = subverbose)
        rm(combinedRGset)
        gc()
        compTable <- get(paste0(referencePkg, ".compTable"))
        combinedMset <- combinedMset[which(rownames(combinedMset) %in% 
            rownames(compTable)), ]
    }
    else {
        if (!is(combinedRGset, "RGChannelSet")) 
            combinedRGset@preprocessMethod["rg.norm"] <- "Raw (no normalization or bg correction)"
        combinedMset <- processMethod(combinedRGset)
        rm(combinedRGset)
        gc()
    }
    referenceMset <- combinedMset[, combinedMset$studyIndex == 
        "reference"]
    colData(referenceMset) <- as(referencePd, "DataFrame")
    mSet <- combinedMset[, combinedMset$studyIndex == "user"]
    colData(mSet) <- as(colData(rgSet), "DataFrame")
    rm(combinedMset)
    if (probeSelect != "IDOL") {
        if (verbose) 
            message(strwrap("[estimateCellCounts2] Picking probes for \n                            composition estimation.\n", 
                width = 80, prefix = " ", initial = ""))
        compData <- pickCompProbes2(referenceMset, cellTypes = cellTypes, 
            compositeCellType = compositeCellType, probeSelect = probeSelect)
        #output all probes 
        compData <<- compData
        coefs <- compData$coefEsts
        if (verbose) 
            message("[estimateCellCounts2] Estimating composition.\n")
        counts <- projectCellType(getBeta(mSet)[rownames(coefs), 
            ], coefs, lessThanOne = lessThanOne)
        rownames(counts) <- colnames(rgSet)
        if (meanPlot) {
            smeans <- compData$sampleMeans
            smeans <- smeans[order(names(smeans))]
            sampleMeans <- c(colMeans(minfi::getBeta(mSet)[rownames(coefs), 
                ]), smeans)
            sampleColors <- c(rep(1, ncol(mSet)), 1 + as.numeric(factor(names(smeans))))
            plot(sampleMeans, pch = 21, bg = sampleColors)
            legend("bottomleft", c("blood", levels(factor(names(smeans)))), 
                col = seq_len(7), pch = 15)
        }
        if (returnAll) {
            list(counts = counts, compTable = compData$compTable, 
                normalizedData = mSet)
        }
        else {
            list(counts = counts)
        }
    }
    else {
        if (verbose) 
            message(strwrap("[estimateCellCounts2] Using IDOL L-DMR probes for \n                            composition estimation.\n", 
                width = 80, prefix = " ", initial = ""))
        p <- getBeta(referenceMset)
        pd <- as.data.frame(colData(referenceMset))
        rm(referenceMset)
        if (!is.null(cellTypes)) {
            if (!all(cellTypes %in% pd$CellType)) 
                stop(strwrap("elements of argument 'cellTypes' is not part of \n                            'referenceMset$CellType'", 
                  width = 80, prefix = " ", initial = ""))
            keep <- which(pd$CellType %in% cellTypes)
            pd <- pd[keep, ]
            p <- p[, keep]
        }
        pd$CellType <- factor(pd$CellType, levels = cellTypes)
        ffComp <- rowFtests(p, pd$CellType)
        tIndexes <- split(seq(along = pd$CellType), pd$CellType)
        prof <- vapply(tIndexes, function(i) rowMeans(p[, i]), 
            FUN.VALUE = numeric(dim(p)[1]))
        r <- rowRanges(p)
        compTable <- cbind(ffComp, prof, r, abs(r[, 1] - r[, 
            2]))
        names(compTable)[1] <- "Fstat"
        names(compTable)[c(-2, -1, 0) + ncol(compTable)] <- c("low", 
            "high", "range")
        tstatList <- lapply(tIndexes, function(i) {
            x <- rep(0, ncol(p))
            x[i] <- 1
            return(rowttests(p, factor(x)))
        })
        trainingProbes <- IDOLOptimizedCpGs
        trainingProbes <- trainingProbes[trainingProbes %in% 
            rownames(p)]
        p <- p[trainingProbes, ]
        pMeans <- colMeans(p)
        names(pMeans) <- pd$CellType
        form <- as.formula(sprintf("y ~ %s - 1", paste(levels(pd$CellType), 
            collapse = "+")))
        phenoDF <- as.data.frame(model.matrix(~pd$CellType - 
            1))
        colnames(phenoDF) <- sub("^pd\\$CellType", "", 
            colnames(phenoDF))
        if (ncol(phenoDF) == 2) {
            X <- as.matrix(phenoDF)
            coefEsts <- t(solve(t(X) %*% X) %*% t(X) %*% t(p))
            coefs <- coefEsts
        }
        else {
            tmp <- validationCellType(Y = p, pheno = phenoDF, 
                modelFix = form)
            coefEsts <- tmp$coefEsts
            coefs <- coefEsts
        }
        compData <- list(coefEsts = coefEsts, compTable = compTable, 
            sampleMeans = pMeans)
        if (verbose) 
            message("[estimateCellCounts2] Estimating composition.\n")
        counts <- projectCellType(getBeta(mSet)[rownames(coefs), 
            ], coefs, lessThanOne = lessThanOne)
        rownames(counts) <- colnames(rgSet)
        if (meanPlot) {
            smeans <- compData$sampleMeans
            smeans <- smeans[order(names(smeans))]
            sampleMeans <- c(colMeans(getBeta(mSet)[rownames(coefs), 
                ]), smeans)
            sampleColors <- c(rep(1, ncol(mSet)), 1 + as.numeric(factor(names(smeans))))
            plot(sampleMeans, pch = 21, bg = sampleColors)
            legend("bottomleft", c("blood", levels(factor(names(smeans)))), 
                col = seq_len(7), pch = 15)
        }
        if (returnAll) {
            list(counts = counts, compTable = compTable, normalizedData = mSet)
        }
        else {
            list(counts = counts)
        }
    }
}


```



Deconvolution of CBMCs (cord blood) and year 1 PBMCs using cordblood reference sets using estimateCellCounts2 and FlowSorted.CordBloodCombined.450k 
```{r child_fscbc_ecc2}
hub <- ExperimentHub()
myfiles <- query(hub, "FlowSorted.CordBloodCombined.450k")
FlowSorted.CordBloodCombined.450k <- myfiles[[1]]
FlowSorted.CordBloodCombined.450k



#CBMCs (cordblood) with cord blood reference set 
#dont include granulocytes since they are not expected in CBMCs
child_fscbc_ecc2_cb <- estimateCellCounts2Probes(cb_rgset, 
                            compositeCellType = "CordBlood",
                            processMethod = "preprocessNoob",
                            cellTypes = c("CD4T","NK","nRBC","Bcell","Mono","CD8T"), 
                            referencePlatform = "IlluminaHumanMethylation450k",
                            referenceset = "FlowSorted.CordBloodCombined.450k",
                            returnAll = FALSE) 


#year 1 PBMCs with cordblood reference set
#dont include granulocytes or nRBCs since neither are expected in year 1 PBMCs
child_fscbc_ecc2_y1 <- estimateCellCounts2(y1_rgset, 
                            compositeCellType = "CordBlood",
                            processMethod = "preprocessNoob",
                            cellTypes = c("CD4T","NK", "Bcell","Mono","CD8T"), 
                            referencePlatform = "IlluminaHumanMethylation450k",
                            referenceset = "FlowSorted.CordBloodCombined.450k",
                            returnAll = FALSE) 
```



Save deconvoluted data.    
```{r deconvo_data}
save(child_fscbc_ecc2_cb, child_fscbc_ecc2_y1, file=here("output_data","deconvolution", "2020-11-10_CBMC_PBMC_deconvolution.Rdata"))
```

