---
title: "Year one postnatal regression using limma with complete cases"
author: "SL"
date: "March 04, 2021"
output: html_document
---

*Purpose*: The purpose of this script is to DNAm changes in year one PBMCs associated with year one air pollution exposure (proxied by no2). This script uses a subtraction method to "cancel" out effects of prenatal exposure, allowing the investigation of year one specific changes. 


Set global chunk options. 
```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Load required libraries.
```{r libraries}
library(tidyverse) # be tidy
library(limma) # for DNAm differences
library(here) # file calling
library(pbapply) # for running lm for each cpg
library(piecewiseSEM) # for getting partial residuals
library(broom) # tidy function for summarizing lm
library(sva) # for calculating SVs
library(ggcorrplot) # correlation matrix
```


Load  betas data
```{r covariates}
load(file=here("output_data", "preprocessed_data",
               "2021-01-14_CHILD_preprocessed_betas_pdata_annotation.Rdata"))
```


Load covariate data
```{r covariates}
# load covariate file
load(file=here("output_data", "covariates", "2020-11-12_CHILD_covariates_na_with_means.Rdata"))

#######################################################
# subset out cord blood and year one pdata separately #
#######################################################

# cord blood pdata
cb_pdata <- subset(pdata_nodups, Tissue == "C")
# check size of cord blood pdata
dim(cb_pdata) # 144  17

# year one pdata
y1_pdata <- subset(pdata_nodups, Tissue == "P")
# check size of year one pdata
dim(y1_pdata) # 145  17

# year one data has one individual that is missing birth data
# remove this individual
y1_pdata_sub <- y1_pdata[y1_pdata$Sample_Label %in% cb_pdata$Sample_Label, ]
# recheck size of year one pdata
dim(y1_pdata_sub) # 144  17
```


Subset out cord blood and age one betas
```{r sub_betas}
####################
# cord blood betas #
####################

# subset cord blood betas based on pdata
# all children with cord blood betas also have year one DNAm data
cb_betas <- betas[,colnames(betas) %in% rownames(cb_pdata)]

#check size of cord blood data
dim(cb_betas) # 424644    144
min(cb_betas) # 0.002973941
max(cb_betas) # 0.9980669

# check if cord blood DNAm samples are in same order in cord blood pdata
identical(colnames(cb_betas), rownames(cb_pdata)) # TRUE

# rename columns of cb_betas to sample label (5 digit identifier)
colnames(cb_betas) <- cb_pdata$Sample_Label

##################
# year one betas #
##################

# subset out year one DNAm samples from beta matrix
y1_betas <- betas[,colnames(betas) %in% rownames(y1_pdata_sub)]

# check size of year one data
dim(y1_betas) # 424644    144
min(y1_betas) # 0.002650193
max(y1_betas) # 0.9983506

# check if year one DNAm samples are in same order in year one pdata
identical(colnames(y1_betas), rownames(y1_pdata_sub)) # TRUE

# rename columns of cb_betas to sample label (5 digit identifier)
colnames(y1_betas) <- y1_pdata_sub$Sample_Label

# check if cord blood samples and year one samples are in same order
identical(colnames(cb_betas), colnames(y1_betas)) # TRUE
```


Subtract cord blood DNAm data from year one DNAm data to isolate postnatal DNAm changes. 
```{r diff_betas}
# call postnatal DNAm data "diff betas"
diff_betas <- y1_betas - cb_betas

# check size of difference betas
dim(diff_betas) # 424644    144
min(diff_betas) # -0.9793121 
max(diff_betas) # 0.9797916
```


Load combined cell type PCs (CBMC and PBMC together).
```{r load_celltype_PCs}
# load cell type PCs for diff betas
load(here("output_data", "deconvolution", 
          "2021-02-04_CHILD_CBMC_PBMC_PCs.Rdata"))

# check size
dim(ccc_pcs) # 144 11

# rename columns for clarity
colnames(ccc_pcs) <- paste("celltype.", colnames(ccc_pcs), sep="")
```


Load genotyping PCs. There are PCs for all CHILD participants that were genotyped. Therefore we have to subset the REEGLE participants used in this study out.
```{r genotypingPCS}
# load genotyping data
genotyping <- read.csv(here("input_data", "genotyping", "CHILD_subjects_Qced_first10PCS_Duan.csv"))
  
# make rownames the sample label (5 digit identifier)
rownames(genotyping) <- genotyping$FID

# remove columns that contain naming info since this is now in rownames
genotyping <- subset(genotyping, select=-c(FID, IID))

# subset REEGLE genotyping PCs
genosub <- genotyping[rownames(genotyping) %in% cb_pdata$Sample_Label,]

# check size
dim(genosub) # 131 10

# rename columns of genotyping data for clarity
colnames(genosub) <- paste("genotyping.", colnames(genosub), sep="")

# put rows in numerical order according to sample id
genosub_order <- genosub[order(rownames(genosub)), ]
```


Subset covariates, betas, pdata, and cell type PCs for samples that also have genotyping.
```{r sub_on_geno}
############
# cb pdata #
############

# subset cb_pdata
cb_pdata_geno <- cb_pdata[as.character(cb_pdata$Sample_Label) %in%
                            rownames(genosub_order), ]
# check size
dim(cb_pdata_geno) # 131

# check order
identical(as.character(cb_pdata_geno$Sample_Label), 
          rownames(genosub_order)) # TRUE

############
# y1 pdata #
############

# subset y1_pdata
y1_pdata_geno <- y1_pdata_sub[as.character(y1_pdata_sub$Sample_Label) %in%
                                rownames(genosub_order), ]
# check size
dim(y1_pdata_geno) # 131 14

# check order
identical(as.character(y1_pdata_geno$Sample_Label), 
          rownames(genosub_order)) # TRUE

##############
# covariates #
##############

# subset covariates
covariates_geno <- 
  covariates_nameans[as.character(covariates_nameans$sampleid) %in%
                     rownames(genosub_order), ]

# check size
dim(covariates_geno) #131

# check order
identical(as.character(covariates_geno$sampleid), 
          rownames(genosub_order)) # TRUE

##############
# diff betas #
##############

# subset betas
diff_betas_geno <- diff_betas[,colnames(diff_betas) %in% 
                                rownames(genosub_order)]

# check size
dim(diff_betas_geno) # 131

# check order
identical(colnames(diff_betas_geno), rownames(genosub_order)) # TRUE

#################
# cell type PCs #
#################

# subset celltype pcs
ccc_pcs_geno <- ccc_pcs[rownames(ccc_pcs) %in% rownames(genosub_order), ]

# check size
dim(ccc_pcs_geno) # 131 11

# check order
identical(rownames(ccc_pcs_geno), rownames(genosub_order)) # TRUE
```


Combine covariates with genotyping data, cell type PCs, and batch variables from pdata. 
```{r combine_data}

################################
# clean pdata before combining #
################################

# refactor and label new columns for cord blood batch vars
cb_pdata_geno$cb_chip <- as.factor(cb_pdata_geno$Sentrix_ID)
cb_pdata_geno$cb_run <- as.factor(cb_pdata_geno$Run)
cb_pdata_geno$cb_row <-
  as.numeric(as.factor(substr(cb_pdata_geno$Sentrix_Position, 1, 3)))

# refactor and label  new columns for year one batch vars
y1_pdata_geno$y1_chip <- as.factor(y1_pdata_geno$Sentrix_ID)
y1_pdata_geno$y1_run <- as.factor(y1_pdata_geno$Run)
y1_pdata_geno$y1_row <-
  as.numeric(as.factor(substr(y1_pdata_geno$Sentrix_Position, 1, 3)))

#######################
# combine data frames #
#######################

covariates_geno_ctpcs_tech <- cbind(covariates_geno,
                                    ccc_pcs_geno,
                                    genosub_order,
                                    cb_pdata_geno[,c("cb_run", 
                                                     "cb_row",
                                                     "cb_chip")],
                                    y1_pdata_geno[,c("y1_run", 
                                                     "y1_row",
                                                     "y1_chip")])

# check classes
lapply(covariates_geno_ctpcs_tech, class)

# reclass sex
covariates_geno_ctpcs_tech$sex <- as.factor(covariates_geno_ctpcs_tech$sex)
``` 



Subset covariates and betas for complete cases 
```{r complete_cases}
##############
# covariates #
##############

# covariate complete cases
covariates_geno_ctpcs_tech_cc <- 
  covariates_geno_ctpcs_tech[covariates_geno_ctpcs_tech %>% 
                             dplyr::select(no2_y1_entire, sex,  
                                           maternal_smoking_y1,  
                                           maternal_education_length, 
                                           pss_6mos,
                                           csed_6mos, 
                                           genotyping.PC1, 
                                           genotyping.PC2,
                                           genotyping.PC3,
                                           celltype.PC1, celltype.PC2,
                                           celltype.PC3, celltype.PC4,
                                           celltype.PC5, celltype.PC6,
                                           celltype.PC7, celltype.PC8,
                                           celltype.PC9) %>% complete.cases,] 

# check size of complete case covariates
dim(covariates_geno_ctpcs_tech_cc) # 125 140

#########
# betas #
#########

#subset betas
diff_betas_geno_cc <- 
  diff_betas_geno[,colnames(diff_betas_geno) %in%
                    covariates_geno_ctpcs_tech_cc$sampleid]
# check size
dim(diff_betas_geno_cc) # 424644    125

# remove betas that were used for cell type prediction
diff_betas_geno_cc_cpr <- 
  diff_betas_geno_cc[!rownames(diff_betas_geno_cc) %in%
                       rownames(cb_deconvolutionprobes$coefEsts) &
                       !rownames(diff_betas_geno_cc) %in%
                       rownames(y1_deconvolutionprobes$coefEsts), ]

# check size
dim(diff_betas_geno_cc_cpr) # 424079 125; 565 probes removed
```


Create model matrix for investigating postnatal DNAm changes. 
```{r model_matrix}
# create model matrix
mod <- model.matrix(~ no2_y1_entire + 
                      sex +
                      maternal_smoking_y1 + 
                      maternal_education_length +
                      pss_6mos + 
                      genotyping.PC1 + genotyping.PC2 + genotyping.PC3 + 
                      celltype.PC1 + celltype.PC2 + celltype.PC3 + 
                      celltype.PC4 + celltype.PC5 + celltype.PC6 +
                      celltype.PC7 + celltype.PC8 + celltype.PC9, 
                    data=covariates_geno_ctpcs_tech_cc)

# check size
dim(mod) # 125 19
```


Surrogate variable analysis using the sva packages. This will allow us to capture variance due to batch effects, as well as variance due to unkown biological variables. 
```{r sva}
#################
# calculate svs #
#################

# create null matrix
# this matrix does not include any of our covariates 
# this means that our covariates are "protected" and SVs will not capture them
mod0 <- model.matrix(~ 1, data=covariates_geno_ctpcs_tech_cc)


################
# sva analysis #
################

# to get SVs in a way that allows calculation of their variance
# we need to pull the code out of sva and run it line-by-line
# we are using the "Be" method for calculating SVs

######################################
# irwsva required internal functions #
######################################

# edge.lfdr function is internal to irwsva function below
# mono function is internal to edge.lfdr
# they have to be initialized before we can run the rest of the code

mono <- function(lfdr){
  .Call("monotone", as.numeric(lfdr), PACKAGE="sva")
}

edge.lfdr <- function(p, trunc=TRUE, monotone=TRUE, transf=c("probit", "logit"), adj=1.5, eps=10^-8, lambda=0.8, ...) {
  pi0 <- mean(p >= lambda)/(1 - lambda)
  pi0 <- min(pi0, 1)
  n <- length(p)
  transf <- match.arg(transf)
  if(transf=="probit") {
    p <- pmax(p, eps)
    p <- pmin(p, 1-eps)
    x <- qnorm(p)
    myd <- density(x, adjust=adj)
    mys <- smooth.spline(x=myd$x, y=myd$y)
    y <- predict(mys, x)$y
    lfdr <- pi0*dnorm(x)/y
  }
  if(transf=="logit") {
    x <- log((p+eps)/(1-p+eps))
    myd <- density(x, adjust=adj)
    mys <- smooth.spline(x=myd$x, y=myd$y)
    y <- predict(mys, x)$y
    dx <- exp(x) / (1+exp(x))^2
    lfdr <- pi0 * dx/y
  }
  if(trunc) {
    lfdr[lfdr > 1] <- 1
  }
  if(monotone) {	
    lfdr <- lfdr[order(p)]
    lfdr <- mono(lfdr)
    lfdr <- lfdr[rank(p)]
  }
  return(lfdr)
}



##################################
# numsv function internal to sva #
##################################

#determine the number of required SVs
#this is numsv function code pulled out

#this is what is fed into this function from the sva function
dat = diff_betas_geno_cc_cpr
mod = mod
#method="be" # this is the default and what is called by numsv
#vfilter=NULL # we dont apply a filter and its not used for be method
B=20
set.seed(1234)

# initialize some stuff
# get the residual matrix (the remaining variance)
n <- ncol(dat)
m <- nrow(dat)
H <- mod %*% solve(t(mod) %*% mod) %*% t(mod)
res <- dat - t(H %*% t(dat))

# run svd and get some eigenvalues
uu <- svd(res)
# get the num of "sig" eigenvalues
ndf <- min(m, n) - ceiling(sum(diag(H)))
# get percent variance explained by each eigenvalue
dstat <- uu$d[1:ndf]^2/sum(uu$d[1:ndf]^2)
# initialize null distribution matrix
dstat0 <- matrix(0, nrow = B, ncol = ndf)

# set seed here since we are calling sample
# create the null distribution
for (i in 1:B) {
  # this part of the code removes all relationships in the 
  res0 <- t(apply(res, 1, sample, replace = FALSE))
  res0 <- res0 - t(H %*% t(res0))
  # calculate svs on this
  uu0 <- svd(res0)
  # bind their explained variance in null matrix
  dstat0[i, ] <- uu0$d[1:ndf]^2/sum(uu0$d[1:ndf]^2)
  print(i) # print out the iteration we are on
}

# determine the number of svs required here based on pvalues
psv <- rep(1, n)
for (i in 1:ndf) {
  psv[i] <- mean(dstat0[, i] >= dstat[i])
}
for (i in 2:ndf) {
  psv[i] <- max(psv[(i - 1)], psv[i])
}

# this is the variable holding the number of SVs required 
# number is each to all the svs with a pval less than/equal to 0.1
nsv <- sum(psv <= 0.1)


####################################
# code from the main SVA function  #
####################################

n.sv = nsv # from code above (run internally when sva called)
B = 5 # number of iterations
  
# dat =  betas # already initialized
# mod = mod  # already initialized
# mod0 = mod0  # already initialized 
# controls = NULL # we dont include controls - only for supervised method
# method = "irw" # this isnt actually used but would be called by sva
# vfilter = NULL # we dont set this when running sva
# numSVmethod = "be" # this is the default called by sva (code above)
  

###################################
# irwsva function internal to sva #
###################################

# this code is really want does all the work in sva
# we use the irw method so this is the code for that method
# there are also supervised and two step methods (not used by us)

# irw function takes input from sva, so we have already defined below vars
# dat = dat 
# mod = mod
# mod0 = mod0
# n.sv = n.sv
# B = B

# intialize variables again
n <- ncol(dat)
m <- nrow(dat)
Id <- diag(n)
resid <- dat %*% (Id - mod %*% solve(t(mod) %*% mod) %*% t(mod))
uu <- eigen(t(resid) %*% resid)
vv <- uu$vectors
ndf <- n - dim(mod)[2]
pprob <- rep(1, m)
one <- rep(1, n)
Id <- diag(n)
df1 <- dim(mod)[2] + n.sv
df0 <- dim(mod0)[2] + n.sv
rm(resid)

cat(paste("Iteration (out of", B, "):"))
for (i in 1:B) {
  mod.b <- cbind(mod, uu$vectors[, 1:n.sv])
  mod0.b <- cbind(mod0, uu$vectors[, 1:n.sv])
  ptmp <- f.pvalue(dat, mod.b, mod0.b)
  pprob.b <- (1 - edge.lfdr(ptmp))
  mod.gam <- cbind(mod0, uu$vectors[, 1:n.sv])
  mod0.gam <- cbind(mod0)
  ptmp <- f.pvalue(dat, mod.gam, mod0.gam)
  pprob.gam <- (1 - edge.lfdr(ptmp))
  pprob <- pprob.gam * (1 - pprob.b)
  dats <- dat * pprob
  dats <- dats - rowMeans(dats)
  uu <- eigen(t(dats) %*% dats)
  cat(paste(i, " "))
}

# this is what is normally returned by sva
# problem is that it doesnt include the diagonal matrix we want
sv = svd(dats)$v[, 1:n.sv, drop = FALSE] 
svobj <- list(sv = sv, pprob.gam = pprob.gam, pprob.b = pprob.b, 
               n.sv = n.sv)

# to get all info (including diagonal)
svobj_all <- svd(dats)


#####################
# heat scree of SVs #
#####################

# from elodie portales-casamar

# heat scree prepartion
vars <- svobj_all[['d']]^2
vars <- vars/sum(vars)
names(vars) <- paste0('SV', 1:length(vars))
xp <- 1:svobj$n.sv
varsdf <- as.data.frame(vars)
varsdf$svnum <- rep(1:length(vars))

# heat scree ggplot!! 
ggplot(varsdf[1:nsv,], aes(x=svnum, y=vars)) +
  geom_col() +
  theme_bw() +
  labs(x="Surrogate Variables", y = "Percentage of Variance")

# it looks liek the first two svs are important
# examine a correlation matrix between all svs and covariates to see
# what variance they are capturing


######################
# correlation matrix #
######################

# add svs to covariates
covariates_geno_ctpcs_tech_cc <- cbind(covariates_geno_ctpcs_tech_cc, svobj$sv)

# rename columns with svs
colnames(covariates_geno_ctpcs_tech_cc)[141:155] <-
  paste("sv",colnames(covariates_geno_ctpcs_tech_cc)[141:155], sep="")

corr <- round(cor2(covariates_geno_ctpcs_tech_cc %>% 
                select(-no_vaccines_6mos,
                       -clinician_wheeze_dx_y3,
                       -reported_asthma_dx_y1,
                       -move_6m, -move_3m)))

corrsub <- corr[,136:150]

ggcorrplot(corr=corrsub,
           #p.mat=pvalsub,
           #insig = "blank",
           type = "lower", 
           #lab=TRUE,
           #lab_size = 2,
           tl.cex =6, 
           colors = c("#6D9EC1", "white", "#E46726")) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        legend.position="left") +
  scale_y_discrete(position = "right")



######################################
# heat scree plot of svs against pcs #
######################################

# have to use betas for this as diff betas contain negative values
# cant convert negative beta to m-value

#pca 
uncor.dat <- t(scale(t(diff_betas_geno_cc_cpr)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- 
  covariates_geno_ctpcs_tech_cc[,c("sex", "maternal_smoking_y1",
                                  "cb_run", "cb_chip", "y1_run", "y1_chip")] 
meta_continuous <- 
  covariates_geno_ctpcs_tech_cc[,c("no2_y1_entire",
                                  "maternal_education_length", 
                                  "pss_6mos", "csed_6mos",
                                  "cb_row", "y1_row", 
                                  "celltype.PC1", "celltype.PC2",
                                  "celltype.PC3", "celltype.PC4",
                                  "celltype.PC5", "celltype.PC6",
                                  "celltype.PC7", "celltype.PC8",
                                  "celltype.PC9", 
                                  "genotyping.PC1", "genotyping.PC2",
                                  "genotyping.PC3", "sv1", "sv2", "sv3",
                                  "sv4", "sv5", "sv6", "sv7", "sv8",
                                  "sv9", "sv10", "sv11", "sv12", "sv13",
                                  "sv14", "sv15")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:40)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)


############################################################
# point plots to see how well SVs separate batch variables #
############################################################

# cord blood row
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = as.factor(cb_row)),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) 

# cord blood run
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = as.factor(cb_run)),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())


#cord blood chip
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = cb_chip),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_colour_manual(values=c("deeppink1", "green1", "blue1", "purple1",
                               "cyan1", "firebrick1", "seagreen3", "tomato1",
                               "black", "dimgrey", "yellow1", "hotpink1",
                               "aquamarine1", "goldenrod", "darkorange1", "mediumorchid3",
                               "coral2", "deepskyblue", "dodgerblue", "springgreen",
                               "royalblue", "palevioletred", "red", "orange", "maroon"))



# year one row
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = as.factor(y1_row)),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) 


# year one run
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = as.factor(y1_run)),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) 

#y1 chip
ggpairs(covariates_geno_ctpcs_tech_cc, columns=141:155,
          mapping = ggplot2::aes(color = as.factor(y1_chip)),
        upper = "blank",
        lower = list(continuous = wrap("points", alpha = 0.5, size=1)), 
        diag = NULL) +
  theme_bw()  +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_colour_manual(values=c("deeppink1", "green1", "blue1", "purple1",
                               "cyan1", "firebrick1", "seagreen3", "tomato1",
                               "black", "dimgrey", "yellow1", "hotpink1",
                               "aquamarine1", "goldenrod", "darkorange1", "mediumorchid3",
                               "coral2", "deepskyblue", "dodgerblue", "springgreen",
                               "royalblue", "palevioletred", "red", "orange", "maroon"))




###########################
# add SVs to model matrix #
###########################

#Design matrix for limma with surrogate variables
modSv = cbind(mod,svobj$sv[,1:15])
```


```{r limma}

###############
#### LIMMA ####
###############

#fit methylation to no2
diff_fit <-  lmFit(diff_betas_geno_cc_cpr, modSv)
diff_ebayes <- eBayes(diff_fit)

#add annotation to cb_ebayes
#pull annotation for cpgs contained in diff_betas
annotation_cpgs <- annotation[rownames(annotation) %in% rownames(diff_ebayes),]
#check order
identical(rownames(annotation_cpgs), rownames(diff_ebayes)) #false
#match
annotation_cpgs_order <- annotation_cpgs[rownames(diff_ebayes), ]
identical(rownames(annotation_cpgs_order), rownames(diff_ebayes)) #true

diff_ebayes$annotation <- annotation_cpgs_order

#pull out pval, coefficients and annotation
diff_pvals_tech <- cbind(as.data.frame(diff_ebayes$p.value), 
                  as.data.frame(diff_ebayes$coefficients),
                  as.data.frame(diff_ebayes$annotation))

#rename columns to indicate pvalues vs coefficients 
colnames(diff_pvals_tech) <- c(paste("pval", colnames(diff_pvals_tech)[1:33],
                                     sep = "_"), 
                               paste("coeff", colnames(diff_pvals_tech)[34:66], 
                                     sep = "_"),
                               colnames(diff_pvals_tech)[67:99])

diff_pvals_tech$adj_pval_no2_y1_entire <- p.adjust(diff_pvals_tech$pval_no2_y1_entire, method="BH")
```


Examine qqplot and pvalue histogram.
```{r qqplot_pval_histo}
########
#qqplot#
########

# use code from qqman::qq function 
# plot with ggplot to make it more aesthetically appealling 
pvector <- diff_pvals_tech$pval_no2_y1_entire

pvector2 <- pvector[!is.na(pvector) & !is.nan(pvector) & !is.null(pvector) & 
                      is.finite(pvector) & pvector < 1 & pvector > 0]

pval_qq <- as.data.frame(cbind(o = -log10(sort(pvector2, decreasing = FALSE)),
                               e = -log10(ppoints(length(pvector2)))))

#calculate lambda
chisq <- qchisq(1-pvector,1)
lambda <-  median(chisq)/qchisq(0.5,1)
 
ggplot(pval_qq, aes(x=e, y=o)) + 
  geom_point(col="#254A90", size=2) + 
  geom_abline(slope = 1, intercept = 0, 
              col = "red", size=0.25, linetype="dashed") +
  labs(x = "Expected -log10(p-value)",
       y = "Observed -log10(p-value)") +
  annotate("text", x=4, y=1, label = paste("λ = ", round(lambda, 2)), size=4) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title.x = element_text(size=14),
        axis.title.y = element_text(size=14)) +
  ylim(0,6) + 

  ggsave( filename="2021-03-17_CHILD_y1_qqplot.png",
          path =  here("figures", "linear_regression", "yearone"),
          width = 4.5, height = 4, units = "in")
```


Delta beta
```{r db}
range = max(covariates_geno_ctpcs_tech_cc$no2_y1_entire) -
    min(covariates_geno_ctpcs_tech_cc$no2_y1_entire)

diff_pvals_tech$db <- diff_pvals_tech$coeff_no2_y1_entire * range
```



Volcano plot
```{r volcano_db_tech}
#make new column to label sig points with cpgid
diff_pvals_tech$cpgid <- rownames(diff_pvals_tech)

#volcano plot
ggplot(diff_pvals_tech, aes(x=as.numeric(db)*100 , y=-log10(as.numeric(pval_no2_y1_entire)))) +
  geom_point(alpha=0.4, col = "#254A90", size=1) +
  
  #nominal p value cut off
  geom_hline(yintercept = -log10(0.00001), linetype="dashed", size=0.25) + 
  
  #10% effect size cut-off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.1) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.1)), 
             alpha=0.4, col = "red", size=1) + 
  geom_vline(xintercept = c(10, -10), linetype = "dashed", size=0.25) +
  
  # 5% effect size cut off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.05) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.05)), 
             alpha=0.4, col = "red", size=1) + 
  geom_vline(xintercept = c(5, -5), linetype = "dashed", size=0.25) +
  
  
  # 2.5% effect size cut off
  geom_point(data=subset(diff_pvals_tech, 
                         (pval_no2_y1_entire < 0.00001 & db > 0.025) | 
                           (pval_no2_y1_entire < 0.00001 & db < -0.025)), 
             alpha=0.4, col = "red", size=1) + 
  geom_vline(xintercept = c(2.5, -2.5), linetype = "dashed", size=0.25) +
  
  #label significant points
  # ggrepel::geom_text_repel(data=subset(diff_pvals_tech, 
  #                       (pval_no2_y1_entire < 0.00001 & db > 0.025) | 
  #                         (pval_no2_y1_entire < 0.00001 & db < -0.025)),
  #                       mapping=aes(x=as.numeric(db)*100 , y=-log10(as.numeric(pval_no2_y1_entire)),
  #                                   label=cpgid),
  #                      size=6) + 
  
  scale_x_continuous(breaks=c(-25, -10, -5, 0, 5, 10, 25)) +
  labs(y="-log10(unadjusted p-value)", x = "Effect size (methylation %)") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(size=9),
        axis.text.y = element_text(size=9),
        axis.title.x = element_text(size=11),
        axis.title.y = element_text(size=11)) +
  
  ggsave( filename="2021-04-26_CHILD_y1_volcanoplot.png",
          path =  here("figures", "linear_regression", "yearone"),
          width = 7.9, height = 6, units = "cm")
```


Subset out important cpgs
```{r sig_cpgs_tables}
# add db to e bayes
diff_ebayes$db <- diff_pvals_tech$db

# subset based on delta beta
diff_ebayes_sig <- diff_ebayes[diff_ebayes$db > 0.025 | diff_ebayes$db < -0.025, ]

# get top ten significant genes with coefficients and write csv
write.csv(topTable(diff_ebayes_sig, number=10, 
              coef ="no2_y1_entire", sort.by = "P", confint = T),
     here("tables", "yearone", "2021-04-26_toptable_yearone_10cpgs.csv"))

# get top 10 cpgs with manifest annotation
write.csv(subset(diff_pvals_tech, 
            (pval_no2_y1_entire < 0.00005 & db > 0.025) | 
                (pval_no2_y1_entire < 0.00005 & db < -0.025)), 
          here("tables", "yearone", 
               "2021-04-26_top10_postnatal_cpgs.csv"))

# write out all prenatal findings
write.csv(diff_pvals_tech, here("tables", "yearone", 
                              "2021-04-26_ALL_postnatal_cpgs.csv"))
```


Plot marginally "significant" cpgs
```{r sig_cpgs}

###################
# cg07472943 SHC2 #
###################

covariates_geno_ctpcs_tech_cc$cg07472943 <- diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg07472943", ]

cg07472943_lm <- lm(cg07472943 ~ no2_y1_entire + sex + pss_6mos +   
              maternal_smoking_y1 + maternal_education_length +
              celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
              celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 +
              sv7 + sv8 + sv9 + sv10 + sv11 + sv12 + sv13 + sv14 + sv15, 
              data=covariates_geno_ctpcs_tech_cc)

# summary
summary(cg07472943_lm)

# get partial residuals for no2 and dnam 
cg07472943_res <- partialResid(cg07472943 ~ no2_y1_entire, 
                               cg07472943_lm, 
                               data=covariates_geno_ctpcs_tech_cc)

# fit again to get r2
cg07472943_res_fit <- lm(cg07472943_res$yresid ~ cg07472943_res$xresid)

# plot it
ggplot(cg07472943_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  #labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
  #     y="Methylation (%) partial residual") +
  #annotate("text",x=7,y=0.06, label="slope = -0.0982", size=4) +
  #ggtitle("cg05732646") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank(),
        title = element_blank()) +
  ylim(-0.2, 0.2) + 
  
  ggsave(filename="2021-03-17_CHILD_y1_cg07472943_SHC2.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg07472943)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_cg07472943_SHC2.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg07472943, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.1948573


####################
# cg24353392 CRHR1 #
####################

# add dnam values to covariate dataframe
covariates_geno_ctpcs_tech_cc$cg24353392 <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg24353392", ]

# linear regression for partial resids
cg24353392_lm <- lm(cg24353392 ~ no2_y1_entire + sex + pss_6mos +   
              maternal_smoking_y1 + maternal_education_length +
              celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
              celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 +
              sv7 + sv8 + sv9 + sv10 + sv11 + sv12 + sv13 + sv14 + sv15, 
              data=covariates_geno_ctpcs_tech_cc)

# summary
summary(cg24353392_lm)

# get partial residuals for no2 and dnam 
cg24353392_res <- partialResid(cg24353392 ~ no2_y1_entire, 
                               cg24353392_lm, 
                               data=covariates_geno_ctpcs_tech_cc)

# fit again to get r2
cg24353392_res_fit <- lm(cg24353392_res$yresid ~ cg24353392_res$xresid)

# plot
ggplot(cg24353392_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  #labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
  #     y="Methylation (%) partial residual") +
  #annotate("text",x=7,y=0.06, label="slope = -0.0982", size=4) +
  #ggtitle("cg05732646") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank(),
        title = element_blank()) +
  ylim(-0.2,0.2) + 
  
  ggsave(filename="2021-03-17_CHILD_y1_cg24353392_CRHR1.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg24353392)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_cg24353392_CRHR1.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg24353392, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.1039938


####################
# cg18668679 LONP1 #
####################

# add dnam to covariate data frame
covariates_geno_ctpcs_tech_cc$cg18668679 <- diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg18668679", ]

# linear regression for partial resids
cg18668679_lm <- lm(cg18668679 ~ no2_y1_entire + sex + pss_6mos +   
              maternal_smoking_y1 + maternal_education_length +
              celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
              celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
              genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 +
              sv7 + sv8 + sv9 + sv10 + sv11 + sv12 + sv13 + sv14 + sv15, 
              data=covariates_geno_ctpcs_tech_cc)

# summary for slope and unadj p
summary(cg18668679_lm)

#get partial residuals for no2 and dnam 
cg18668679_res <- partialResid(cg18668679 ~ no2_y1_entire, 
                               cg18668679_lm, 
                               data=covariates_geno_ctpcs_tech_cc)

# fit again to get r2
cg18668679_res_fit <- lm(cg18668679_res$yresid ~ cg18668679_res$xresid)

# plot it
ggplot(cg18668679_res, aes(x=xresid, y=yresid)) + 
geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  #labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
  #     y="Methylation (%) partial residual") +
  #annotate("text",x=7,y=0.06, label="slope = -0.0982", size=4) +
  #ggtitle("cg05732646") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank(),
        title = element_blank()) +
  ylim(-0.2,0.2) + 
  
  ggsave(filename="2021-03-17_CHILD_y1_cg18668679_LONP1.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg18668679)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_cg18668679_LONP1.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 3.1, height = 2.6, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg18668679, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.3499418
```





### Gene specific changes

These genes are related to the proposed pathway of air pollution action or have previously been shown to exhibit DNA methylation changes associated with prenatal air pollution exposure. 

```{r gene_specific}
#FHC is FTH1 (ferritin heavy chain 1)
#nothing maps to FOXP3
#TNFA is TNF
goi <- annotation[grep("RNF39|CYP2E1|LONP1|HIBADH|SLC25A28|PLVAP|GPR55|^CAT$|TPO|NFKB1|^NOX2|SOD1|TRX1|TRX2|GSTP1|^MT3|NQO1|HMOX1|GPX1|DDH1|^NOS2|CYP2C11|CYP7B|ALOX12$|ALOX5|^NRF2$|KEAP1|AHR$|^ARNT;|GCLC|GCLM|GSR1|SLC7A11|GPC2|GSTA1|GSTA2|GSTA3|GSTA5|GSTM1|GSTM2|GSTM3|TXN$|TXNRD1$|SRXN1|G6PD|CYP1A1|IL1A|^IL2$|^IL3$|^IL4.*IL4$|^IL5$|^IL6$|IL9$|IL10$|IL12A|IL13|IL15$|IL17A|IL18$|IL19|IL21$|IL22$|IL23A$|IL25$|IL27$|IL31$|IL33$|IFNG$|^TNF$|TGFB1$|FOXP3|FTH1", annotation$UCSC_RefGene_Name), ]


goi <- as.data.frame(goi)
unique(goi$UCSC_RefGene_Name)

# remove pvlap
goi$row <- c(1:nrow(goi))
goi_sub <- goi[-c(902:915), ]
unique(goi_sub$UCSC_RefGene_Name)
#transpose betas
diff_betas_geno_cc_cpr_t <- t(diff_betas_geno_cc_cpr)

#apply function for calculating significance of associations using mice and imputed covariate data
yearone_goi_list <- 
  pbapply(diff_betas_geno_cc_cpr_t [,colnames(diff_betas_geno_cc_cpr_t ) %in% rownames(goi_sub)], 2, function(x) {
  
  combined <- cbind(covariates_geno_ctpcs_tech_cc, x)
  
  #run the linear regression on this cpg using all 5 imputed covariate data sets
  fit <- lm(x ~ no2_y1_entire + sex + pss_6mos +
              maternal_smoking_y1 + maternal_education_length +
              celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
              celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
              celltype.PC9 + genotyping.PC1 + genotyping.PC2 + genotyping.PC3 +
              sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + sv8 + sv9 + sv10 + 
              sv11 + sv12 + sv13 + sv14 + sv15 , data=combined)
  
  #get summary of lm fit
  #this includes coefficients and pvalues
  #coerce into df for manipulation
  #add in terms (rownames) as column for annotation
  fit_sum <- summary(fit)
  fit_sum_coeff <- as.data.frame(fit_sum$coefficients)
  fit_sum_coeff$term <- rownames(fit_sum_coeff)
  
  #this data frame has rows for each linear regression variable, and columns for statistics
  #want a dataframe of 1 row and many columns (one for each variable with each statistic type)
  #do this by using the spread function for each statistics
  #add cpg id onto dataframe for pvalues (to keep track of information)
  #then cbind dataframes together
  
  #coefficient
  estimate <- spread(fit_sum_coeff[,c("term", "Estimate")], term, Estimate)
  colnames(estimate) <- paste("estimate", colnames(estimate), sep=".")
  
  #std error
  std.error <- spread(fit_sum_coeff[,c("term", "Std. Error")], term, 'Std. Error')
  colnames(std.error) <- paste("std.error", colnames(std.error), sep=".")
  
  #t statistics
  statistic <- spread(fit_sum_coeff[,c("term", "t value")], term, 't value')
  colnames(statistic) <- paste("t.val", colnames(statistic), sep=".")

  #pvalue
  p.value <- spread(fit_sum_coeff[,c("term", "Pr(>|t|)")], term, 'Pr(>|t|)')
  colnames(p.value) <- paste("p.value", colnames(p.value), sep=".")
  
  #add in cpgid for annotation 
  p.value$cpg <- colnames(x)
  
  #cbind into wide dataframe
  widepool <- cbind(estimate, std.error, statistic, p.value)
  
  #return the wide dataframe
  #these will be do.call(rbind()) together after
  return(widepool)
  
})


yearone_goi <- do.call(rbind, yearone_goi_list)

yearone_goi$p.value.no2_y1_entire_adjusted <- p.adjust(yearone_goi$p.value.no2_y1_entire, method="bonferroni")

#reorder according ot unadjusted no2 pvalue
yearone_goi_order <- yearone_goi[order(yearone_goi$p.value.no2_y1_entire),]

#reorder goi annotation to be in same order as goi stats
goi_order <- goi[rownames(yearone_goi_order),]

#check identical
identical(rownames(goi_order), rownames(yearone_goi_order)) #true

#bind
yearone_goi_df <- cbind(yearone_goi_order, goi_order)

# order according to pvalue
yearone_goi_df_pval <- yearone_goi_df  %>% arrange(p.value.no2_y1_entire)

#write as .csv
write.csv(yearone_goi_df_pval, 
          here("figures", "linear_regression",
               "yearone", "2021-04-22_yearone_goi.csv"))




##################
#LONP1 cg12283362#
##################

covariates_geno_ctpcs_tech_cc$cg12283362 <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg12283362", ] 

cg12283362_lm <- lm(cg12283362 ~ 
                      no2_y1_entire + sex + pss_6mos +
                      maternal_smoking_y1 + maternal_education_length +
                      celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
                      celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
                      celltype.PC9 + genotyping.PC1 + genotyping.PC2 + genotyping.PC3 +
                      sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + sv8 + sv9 + sv10 + 
                      sv11 + sv12 + sv13 + sv14 + sv15, 
                    data=covariates_geno_ctpcs_tech_cc)

# get lm info
summary(cg12283362_lm)

#get partial residuals for no2 and dnam 
cg12283362_res <- partialResid(cg12283362 ~ no2_preg_entire, cg12283362_lm, 
              data=covariates_geno_ctpcs_tech_cc)

#fit again to get r2
cg12283362_res_fit <- lm(cg12283362_res$yresid ~ cg12283362_res$xresid)

summary(cg12283362_res_fit)

ggplot(cg12283362_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
#  labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
#       y="Methylation (%) partial residual") +
#  annotate("text",x=7,y=0.06, label="slope = -0.377", size=4) +
#  ggtitle("cg12228123") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank(),
        title = element_blank())  +
  ylim(-0.2, 0.2) +
  
  ggsave( filename="2021-03-17_CHILD_cb12283362_LONP1.png",
          path =  here("figures", "linear_regression", "prenatal"),
          width = 3.1,
          height = 2.6,
          units = "in")

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg12283362)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_y1_cg12283362_LONP1.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg12283362, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.004003465



#####################
#SLC25A28 cg08973675#
#####################

covariates_geno_ctpcs_tech_cc$cg08973675 <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg08973675", ] 

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg08973675)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_y1_cg08973675_SLC25A28.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg08973675, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.03784814



##################
# AHR cg13676215 #
##################

covariates_geno_ctpcs_tech_cc$cg13676215 <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg13676215", ] 

# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=cg13676215)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-04-16_CHILD_y1_cg13676215_AHR.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$cg13676215, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.05382739
```


Examine mean methylation vs no2
```{r mean_meth}
#convert betas to df
diff_betas_geno_cc_cpr_df <- as.data.frame(diff_betas_geno_cc_cpr)

methmeans <- colMeans(diff_betas_geno_cc_cpr_df)

covariates_geno_ctpcs_tech_cc <- cbind(covariates_geno_ctpcs_tech_cc, methmeans)

#colmeans
meanmeth_lm <- lm(methmeans ~ no2_y1_entire + sex + pss_6mos + 
                    maternal_smoking_y1 + maternal_education_length +
                    celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
                    celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
                    celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
                    genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + 
                    sv8 + sv9 +  sv10 + sv11 + sv12 + sv13 + sv14 + sv15,
                  data=covariates_geno_ctpcs_tech_cc)

#get summary
summary(meanmeth_lm) #no2 not sig

#get partial residuals for no2 and dnam 
methmean_res <- partialResid( methmeans ~ no2_y1_entire, meanmeth_lm, 
              data=covariates_geno_ctpcs_tech_cc)

#fit again to get r2
methmean_res_fit <- lm(methmean_res$yresid ~ methmean_res$xresid)

summary(methmean_res)

ggplot(methmean_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.6, col = "#254A90", size=3) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  # labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
  #      y= str_wrap("Global DNA methylation (%) partial residual", 30)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=13),
        axis.title = element_blank(),
        title = element_blank())  +
  ylim(-0.2, 0.2) +
  
  ggsave(filename="2021-03-17_CHILD_y1_global_dnam.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")



# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=methmeans)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_y1_global_dnam.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$methmeans, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.05846253
```


```{r get_lineannotation}
#read in line annotation
annotationlines <- read.csv(here("output_data", "linear_regression", "2020-11-29_annotation_LINEs.csv"))

#subset 
annotationlines <- annotationlines[annotationlines$LINEs==T, ]

#subset betas
diff_betas_geno_cc_cpr_lines <- 
  diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr) %in%
                     annotationlines$X, ]

dim(diff_betas_geno_cc_cpr_lines)


#convert betas to df
diff_betas_geno_cc_cpr_lines_df <- as.data.frame(diff_betas_geno_cc_cpr_lines)

linemeth <- colMeans(diff_betas_geno_cc_cpr_lines_df)

covariates_geno_ctpcs_tech_cc$linemeth <- linemeth

#colmeans
linemeth_lm <- lm(linemeth ~ no2_y1_entire + sex + pss_6mos + 
                    maternal_smoking_y1 + maternal_education_length +
                    celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
                    celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
                    celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
                    genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + 
                    sv8 + sv9 +  sv10 + sv11 + sv12 + sv13 + sv14 + sv15,
                  data=covariates_geno_ctpcs_tech_cc)

# summary
summary(linemeth_lm) #no2 not sig

#get partial residuals for no2 and dnam 
linemeth_res <- partialResid(linemeth ~ no2_y1_entire, 
                             linemeth_lm, data=covariates_geno_ctpcs_tech_cc)

#fit again to get r2
linemeth_res_fit <- lm(linemeth_res$yresid ~ linemeth_res$xresid)

summary(linemeth_res_fit)

ggplot(linemeth_res, aes(x=xresid, y=yresid)) + 
  geom_point(alpha=0.6, col = "#254A90", size=3) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  # labs(x=bquote("Prenatal" ~NO[2]~ "(ppb) partial residual"), 
  #      y= str_wrap("Global DNA methylation (%) partial residual", 30)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text = element_text(size=13),
        axis.title = element_blank(),
        title = element_blank())  +
  ylim(-0.2, 0.2) +
  
  ggsave(filename="2021-03-17_CHILD_y1_LINE_dnam.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")



# normal plot
ggplot(covariates_geno_ctpcs_tech_cc,
       aes(x=no2_y1_entire, 
           y=linemeth)) + 
  geom_point(alpha=0.6, col = "#254A90", size=2) + 
  stat_smooth(method="lm", se=F, col="red", size=0.5, linetype="dashed") + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size=12),
        axis.title = element_blank()) +
  ggsave(filename="2021-03-28_CHILD_y1_LINE_dnam.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 4.8, height = 3.2, units = "in")

# correlation 
cor(covariates_geno_ctpcs_tech_cc$linemeth, 
    covariates_geno_ctpcs_tech_cc$no2_y1_entire,
    method="pearson") # -0.05234149
```


Try re-running limma with birth month/ interaction between birth month and air pollution.
```{r interaction_terms_to_assess_birthmonth}
#want to use anova to compare models usign anova
#anova only accepts models from lm
#use lm to compare how birth month affects cpgs above 10^-3 sig 

#You should be able to ask for confidence intervals for the slope coefficients for each month.  #even in a tabular display, you may see that “smoothly varying” pattern we were discussing.
#Then, you could use those to plot a sort of “here’s how the slope varies by month” picture.Sort #of like forest plots for meta analysis results, if that makes sense.

#Also, before we decide it doesn’t matter, the individual slopes might look fairly similar, but the appropriate overall test would be to check the anova(fit_with_interaction) and check the p-value on the interaction term.


################################################
#sig cpg
library(broom)


####################
# cg18668679 LONP1 #
####################

# add dnam to covariates for linear regression
covariates_geno_ctpcs_tech_cc$cg18668679 <- 
        diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg18668679", ]

# linear regression
cg18668679_bm <- lm(cg18668679 ~  no2_y1_entire + sex + pss_6mos + 
                    maternal_smoking_y1 + maternal_education_length +
                    celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
                    celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
                    celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
                    genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + 
                    sv8 + sv9 +  sv10 + sv11 + sv12 + sv13 + sv14 + sv15 +
                    birth_month + no2_y1_entire*birth_month,
                    data=covariates_geno_ctpcs_tech_cc)
                    
# anova to assess significance of interaction term
anova(cg18668679_bm)


tidy(cg18668679_bm, conf.int = 0.95) %>% filter(term %>% str_detect(":")) %>% 
  mutate(term = factor(term, levels=c("no2_y1_entire:birth_monthfebruary",
                                      "no2_y1_entire:birth_monthmarch",
                                      "no2_y1_entire:birth_monthapril",
                                      "no2_y1_entire:birth_monthmay",
                                      "no2_y1_entire:birth_monthjune",
                                      "no2_y1_entire:birth_monthjuly",
                                      "no2_y1_entire:birth_monthaugust",
                                      "no2_y1_entire:birth_monthseptember",
                                      "no2_y1_entire:birth_monthoctober",
                                      "no2_y1_entire:birth_monthnovember",
                                      "no2_y1_entire:birth_monthdecember"))) %>%
  ggplot(aes(y = estimate, x = as.factor(term))) + 
  geom_point() +
  geom_errorbar(aes(ymin = conf.low , ymax = conf.high)) +
  theme_bw() +
  #ggtitle("cg15325658") +
  scale_x_discrete(labels=c("NO2:February","NO2:March", "NO2:April", "NO2:May",
                            "NO2:June","NO2:July", "NO2:August", "NO2:September",
                            "NO2:October", "NO2:November","NO2:December")) +
  labs(x="Interaction term", y="Estimate") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle=90),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14)) +
  
  ggsave(filename="2021-03-17_CHILD_y1_cg18668679_LONP1_birthmonth_aug.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 8.8, height = 4.7, units = "in")


####################
# cg24353392 CRHR1 #
####################

# add dnam to covariates for linear regression
covariates_geno_ctpcs_tech_cc$cg24353392 <- 
        diff_betas_geno_cc_cpr[rownames(diff_betas_geno_cc_cpr)=="cg24353392", ]

# linear regression
cg24353392_bm <- lm(cg24353392 ~  no2_y1_entire + sex + pss_6mos + 
                    maternal_smoking_y1 + maternal_education_length +
                    celltype.PC1 + celltype.PC2 + celltype.PC3 + celltype.PC4 + 
                    celltype.PC5 + celltype.PC6 + celltype.PC7 + celltype.PC8 +
                    celltype.PC9 + genotyping.PC1 + genotyping.PC2 + 
                    genotyping.PC3 + sv1 + sv2 + sv3 + sv4 + sv5 + sv6 + sv7 + 
                    sv8 + sv9 +  sv10 + sv11 + sv12 + sv13 + sv14 + sv15 +
                    birth_month + no2_y1_entire*birth_month,
                    data=covariates_geno_ctpcs_tech_cc)
                    
# anova to assess significance of interaction term
anova(cg24353392_bm)


tidy(cg24353392_bm, conf.int = 0.95) %>% filter(term %>% str_detect(":")) %>% 
  mutate(term = factor(term, levels=c("no2_y1_entire:birth_monthfebruary",
                                      "no2_y1_entire:birth_monthmarch",
                                      "no2_y1_entire:birth_monthapril",
                                      "no2_y1_entire:birth_monthmay",
                                      "no2_y1_entire:birth_monthjune",
                                      "no2_y1_entire:birth_monthjuly",
                                      "no2_y1_entire:birth_monthaugust",
                                      "no2_y1_entire:birth_monthseptember",
                                      "no2_y1_entire:birth_monthoctober",
                                      "no2_y1_entire:birth_monthnovember",
                                      "no2_y1_entire:birth_monthdecember"))) %>%
  ggplot(aes(y = estimate, x = as.factor(term))) + 
  geom_point() +
  geom_errorbar(aes(ymin = conf.low , ymax = conf.high)) +
  theme_bw() +
  #ggtitle("cg15325658") +
  scale_x_discrete(labels=c("NO2:February","NO2:March", "NO2:April", "NO2:May",
                            "NO2:June","NO2:July", "NO2:August", "NO2:September",
                            "NO2:October", "NO2:November","NO2:December")) +
  labs(x="Interaction term", y="Estimate") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle=90),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14)) +
  
  ggsave(filename="2021-03-17_CHILD_y1_cg24353392_CRHR1_birthmonth_aug.png",
         path =  here("figures", "linear_regression", "yearone"),
         width = 8.8, height = 4.7, units = "in")
```








### PC analysis of covariates 

Heat scree plot
```{r heatscree}
#initialize the heatplot function 
#outputs heatmap of PCs
#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot<-function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Create column to name rows accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}



```


PC analysis
```{r pc_covariates}
#load cell type predictions
load("R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution/output_data/deconvolution/2020-11-10_CBMC_PBMC_deconvolution.Rdata")

#convert cell counts to dataframe
child_fscbc_ecc2_cb_df <- as.data.frame(child_fscbc_ecc2_cb)
child_fscbc_ecc2_y1_df <- as.data.frame(child_fscbc_ecc2_y1)

#subset cell counts for participants in pdata
child_fscbc_ecc2_cb_df_sub <-  child_fscbc_ecc2_cb_df[rownames(child_fscbc_ecc2_cb_df) %in%
                                                        rownames(cb_pdata), ]
child_fscbc_ecc2_y1_df_sub <-  child_fscbc_ecc2_y1_df[rownames(child_fscbc_ecc2_y1_df) %in%
                                                        rownames(y1_pdata_sub), ]

#check size
dim(child_fscbc_ecc2_cb_df_sub) #144
dim(child_fscbc_ecc2_y1_df_sub) #144

#check order
identical(rownames(child_fscbc_ecc2_cb_df_sub), rownames(cb_pdata)) #true
identical(rownames(child_fscbc_ecc2_cb_df_sub), rownames(y1_pdata_sub)) #false
identical(y1_pdata_sub$Sample_Label, cb_pdata$Sample_Label) #true
#reorder y1 cell counts to be in same order has y1_data
child_fscbc_ecc2_y1_df_sub_order <- child_fscbc_ecc2_y1_df_sub[rownames(y1_pdata_sub), ]
identical(rownames(child_fscbc_ecc2_y1_df_sub_order), rownames(y1_pdata_sub)) #true

#combine cell counts
colnames(child_fscbc_ecc2_y1_df_sub_order) <- 
  paste("y1", colnames(child_fscbc_ecc2_y1_df_sub_order), sep=".")

allcounts <- cbind(child_fscbc_ecc2_cb_df_sub, child_fscbc_ecc2_y1_df_sub_order)

#rename rownames to participant id (5 digit num)
rownames(allcounts) <- cb_pdata$Sample_Label

#susbet cell counts for complete cases
allcounts_cc <- 
  allcounts[rownames(allcounts) %in%
                               as.character(covariates_ctpcs_geno_tech_cc$sampleid), ]

#check size
dim(allcounts_cc) #125

#check order
identical(rownames(allcounts_cc), 
          as.character(covariates_ctpcs_geno_tech_cc$sampleid)) #true

#combine
covariates_ctpcs_geno_tech_cc <- cbind(covariates_ctpcs_geno_tech_cc,
                                       allcounts_cc)

#PCA
uncor.dat <- t(scale(t(adj_diff_betas_geno_cc)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-20

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:20)


#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
meta_categorical <- covariates_ctpcs_geno_tech_cc[,c("sex", "run", "chip", "maternal_smoking_y1")]

meta_continuous <- covariates_ctpcs_geno_tech_cc[,c("no2_y1_entire", 
                                                    "maternal_education_length", 
                                                    "csed_6mos", "pss_6mos", 
                                                    "counts.CD4T", "counts.CD8T",
                                                    "counts.NK", "counts.Bcell",
                                                    "counts.Mono", "counts.nRBC",
                                                    "y1.counts.CD4T", "y1.counts.CD8T",
                                                    "y1.counts.NK", "y1.counts.Bcell",
                                                    "y1.counts.Mono",
                                                    "row")]

heat_scree_plot(Loadings, Importance, Num, Order)


covariates_ctpcs_geno_tech_cc_num <- as.data.frame(covariates_ctpcs_geno_tech_cc)
covariates_ctpcs_geno_tech_cc_num$sex <- as.factor(covariates_ctpcs_geno_tech_cc_num$sex )
covariates_ctpcs_geno_tech_cc_num$sex <- as.numeric(covariates_ctpcs_geno_tech_cc_num$sex)
covariates_ctpcs_geno_tech_cc_num$prenatal_maternal_smoking <- as.numeric(covariates_ctpcs_geno_tech_cc_num$prenatal_maternal_smoking)
covariates_ctpcs_geno_tech_cc_num$run <- as.numeric(covariates_ctpcs_geno_tech_cc_num$run)

test <- covariates_ctpcs_geno_tech_cc_num[,c("sex", "prenatal_maternal_smoking",
                                              "gestational_days",
                                             "maternal_education_length", 
                                             "pss_18wk", "csed_18wk")]


#variance in data
#prcomp using singular value decomposition (svd)m which examines the covariances / correlations between individuals
all_pca <- prcomp(test, 
                  scale. = TRUE)

#scree plot to visualize how many PCs we need
factoextra::fviz_eig(all_pca, ncp=20) #correct on first 9 pcs

#convert to dataframe
all_pcs <- as.data.frame(all_pca$x)

#examine grouping of pcs
ggpairs(all_pcs, columns=1:10, progress=FALSE)  


#add first two pcs to covariates
covariates_ctpcs_geno_tech_cc_num <- cbind(covariates_ctpcs_geno_tech_cc_num,
                                           all_pca$x[,c("PC1", "PC2", "PC3")])


#create model matrix
cb_design <- model.matrix(~no2_preg_entire + 
                            PC1 +
                            cbmc.PC1 + cbmc.PC2+
                            cbmc.PC3 + cbmc.PC4 + cbmc.PC5 +
                            genotyping.PC1 +
                            genotyping.PC2 +
                            genotyping.PC3 + row + run,
                          data=covariates_ctpcs_geno_tech_cc_num)

#check size
dim(cb_design) #101


#subset betas
cb_betas_geno_cc <- 
  cb_betas_geno[,colnames(cb_betas_geno) %in% covariates_ctpcs_geno_tech_cc_num$sampleid]
#check size
dim(cb_betas_geno_cc) #101

#fit methylation to no2
cb_fit <-  lmFit(cb_betas_geno_cc, cb_design)
cb_ebayes <- eBayes(cb_fit)

#add annotation to cb_ebayes
cb_ebayes$annotation <- annotation[rownames(annotation) %in% rownames(cb_ebayes),]

#pull out pval, coefficients and annotation
cb_pvals_tech <- cbind(as.data.frame(cb_ebayes$p.value), 
                  as.data.frame(cb_ebayes$coefficients),
                  as.data.frame(cb_ebayes$annotation))

#rename columns to indicate pvalues vs coeffcients 
colnames(cb_pvals_tech) <- c(paste("pval", colnames(cb_pvals_tech)[1:13], sep = "_"), 
                         paste("coeff", colnames(cb_pvals_tech)[14:26], sep = "_"),
                         colnames(cb_pvals_tech)[27:59])

ggplot( data = cb_pvals_tech, aes(x=pval_no2_preg_entire)) +
  geom_histogram(bins=100, fill = "#75A2D9") +
  labs(y="Count", x="Unadjusted p-value") +
  theme_bw() +
  theme(panel.border = element_blank(),
        axis.text=element_text(size=18),
        axis.title=element_text(size=20)) 
```



Next examine correlation bewteen variables.
```{r corr}

cor2 = function(df){
  
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  cor_fun <- function(pos_1, pos_2){
    
    # both are numeric
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
      print("both are numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      r <- stats::cor(df[[pos_1]], df[[pos_2]], use = "pairwise.complete.obs")
    }
    
    #one is numberic the other is factor/character
    #must use sum of squares type 3 because groups are not of the same size
    #calculates ANOVA
    #then calcualtes eta-squared: measures the proportion of the total variance in a      dependent variable that
    #is associated with the membership of different groups defined by an independent      variable.
    #takes square root to get correlation
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        r <- 999
      } else {
        #anova for correlation
        r <- stats::aov(df[[pos_1]] ~ as.factor(df[[pos_2]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
      }
      rm(tmp,tmp2)
    }
    
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        r <- stats::aov(df[[pos_2]] ~ as.factor(df[[pos_1]])) %>%
          lsr::etaSquared(type=3) %>% `[`(1) %>% sqrt()
      }
      rm(tmp,tmp2)
    }
    
    
    #both are factor/character
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        r <- 999
      } else {
        if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
          r <-999
        } else { 
          r <- lsr::cramersV(df[[pos_1]], df[[pos_2]], simulate.p.value = TRUE)
        }
      }
      rm(tmp,tmp2)
    }
    return(r)
  } 
  
  cor_fun <- Vectorize(cor_fun)
  
  # now compute corr matrix
  corrmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) cor_fun(x, y)
  )
  
  rownames(corrmat) <- colnames(df)
  colnames(corrmat) <- colnames(df)
  return(corrmat)
}


pval2 = function(df){
  
  #check that classes are appropriate
  print("checking dataframe clases")
  stopifnot(inherits(df, "data.frame"))
  stopifnot(sapply(df, class) %in% c("integer"
                                     , "numeric"
                                     , "factor"
                                     , "character"))
  
  print("calculating correlation matrix")
  
  ##################################
  #function for calculating pvalues#
  ##################################
  
  pval_fun <- function(pos_1, pos_2){
    

    ##################
    #both are numeric#
    ##################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("integer", "numeric")){
        
      print("both are numeric")
      
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        #dont want to star comparisons of something against itsself
        p <- 1
      } else {
        print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
        p <- unname((summary(lm(df[[pos_1]] ~ df[[pos_2]]))$coefficients[,4])[2])
      }
    }
  
    ########################################
    #first is integer and second is numeric#
    ########################################
    
    if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is numeric, second is factor")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_2 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,2] <- as.factor(tmp2[,2])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,2]) & (nlevels(droplevels(tmp2[,2]))<2)){
        p <- 999
      } else {
       if(nlevels(droplevels(tmp2[,2]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_1]] ~ as.factor(df[[pos_2]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_1]] ~ as.factor(df[[pos_2]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ########################################
    #second is integer and first is numeric#
    ########################################
    
    if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
       class(df[[pos_1]]) %in% c("factor", "character")){
      
      #print statements for debugging
      print("first is factor, second is numeric")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
      #check factor levels of complete cases
      print("checking levels of pos_1 factor")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
        p <- 999
      } else {
        if(nlevels(droplevels(tmp2[,1]))>2){
          #anova for p-pval with 3 or  more factors
          lm_p <- lm(df[[pos_2]] ~ as.factor(df[[pos_1]]))
          p <- (anova(lm_p))$`Pr(>F)`[1]
        } else{
          #ttest for 2 factors
          p <- t.test(df[[pos_2]] ~ as.factor(df[[pos_1]]),
                  alternative = "two.sided")$p.value
        }
      }
      rm(tmp,tmp2)
    }
    
    
    ###########################
    #both are factor/character#
    ###########################
    
    if(class(df[[pos_1]]) %in% c("factor", "character") &&
       class(df[[pos_2]]) %in% c("factor", "character")){
      
      #print statement for debugging
      print("both are characters")
      print(paste(colnames(df)[[pos_1]], colnames(df)[[pos_2]]))
      
       #check factor levels of complete cases
      print("checking levels of of both positions")
      tmp <- data.frame(df[[pos_1]], df[[pos_2]], row.names = NULL)
      complete <- complete.cases(tmp)
      tmp2 <- tmp[complete,]
      tmp2[,1] <- as.factor(tmp2[,1])
      tmp2[,2] <- as.factor(tmp2[,2])
      
      
      #if statement to catch cases where dropped values result in a factor with
      #one or fewer levels
      if(colnames(df)[[pos_1]] == colnames(df)[[pos_2]]){
        p <- 1
      } else {
        if(is.factor(tmp2[,1]) && (nlevels(droplevels(tmp2[,1]))<2)){
          p <- 999
        } else {
          if(is.factor(tmp2[,2]) && (nlevels(droplevels(tmp2[,2]))<2)){
            p <- 999
          } else {
            #get p value
            fish_table <- table(df[[pos_1]], df[[pos_2]])
            p <- fisher.test(fish_table, simulate.p.value = T)$p.value
          }
        }
      }
      rm(tmp,tmp2)
    }
    return(p)
  } 
  
  pval_fun <- Vectorize(pval_fun)
  
  # now compute corr matrix
  pvalmat <- outer(1:ncol(df)
                   , 1:ncol(df)
                   , function(x, y) pval_fun(x, y)
  )
  
  rownames(pvalmat) <- colnames(df)
  colnames(pvalmat) <- colnames(df)
  return(pvalmat)
}


```

```{r heat_plot}

#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot <- function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Rename rownames accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}

```
