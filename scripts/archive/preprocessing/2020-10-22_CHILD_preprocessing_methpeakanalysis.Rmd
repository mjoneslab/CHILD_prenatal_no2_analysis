---
title: "CHILD data processing and normalization"
author: "SL"
date: "2020-10-22"
output: html_document
---

Load libraries needed for CHILD data.  
```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(minfi)
library(sva)
library(ggpubr)
library(reshape2)
library(RColorBrewer)
library(here)
```

Set here path.
```{r here}
set_here(path="R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution")
#check path
here()
```

Read CHILD data in based on sample sheet provided - incorporates pData into rgset.  
In sample sheet C = cordblood and P = PMBCs.  
```{r import_data, message=FALSE, warning=FALSE}
#read in sample sheet for child data
sample_sheet <- read.metharray.sheet("R:/Jones/Projects/CHILD/CHILD raw data", pattern = ".csv$",
                                     recursive = FALSE, verbose = TRUE)

#change column names to what minfi expects
colnames(sample_sheet)[8] <- "Sentrix_ID"
colnames(sample_sheet)[9] <- "Sentrix_Position"

#one of the barcodes has a typo in sample sheet -> fix
sample_sheet[sample_sheet$Sentrix_ID == 9343114974, "Sentrix_ID"] <- 9343114074

#create a new column for basename - what read.metharray.exp looks for in targets is called
sample_sheet$Basename <- paste(sample_sheet$Sentrix_ID, 
                               sample_sheet$Sentrix_Position,
                               sep = "_") 

#add in sub directory
sample_sheet$Basename <- paste(sample_sheet$Sentrix_ID, 
                               sample_sheet$Basename,
                               sep = "/") 

#add in main directory
sample_sheet$Basename <- paste("R:/Jones/Projects/CHILD/CHILD raw data",
                               sample_sheet$Basename,
                               sep = "/") 

#read in meth array data
rgset <- read.metharray.exp(targets = sample_sheet, verbose=TRUE)
```

Remove bad probes based on detectionP value. Probes with at least one badDetP will be removed.  
```{r remove_bad_probes}
#samples with a (relatively) high proportion of bad probes should be removed

#fitler out probes with a detectionP value greater than  0.01
#requires RGSet 
badDetP <- detectionP(rgset)>0.01

#visual how many bad probes per sample
#first sum bad detP according to TRUE=1/FALSE=0 and put in data frame
nbaddetP_colsums <-as.data.frame(colSums(badDetP)) 
#add in sample_ID
nbaddetP_colsums$sample_id <- rgset$SampleID
#plot number of bad probes vs sample
ggplot(nbaddetP_colsums, aes(x=sample_id, y=colSums(badDetP))) +
  geom_col() +
  theme_classic() +
  labs(y="Number of failed probes") +
  rotate_y_text()

#find sample with large number of bad probes
nbaddetP_colsums$sample_id[nbaddetP_colsums$`colSums(badDetP)` == max(nbaddetP_colsums$`colSums(badDetP)`)]
  
#one sample (50602_C) has a higher number of failed probes than the rest
#remove before normalization
rgset_nobadsamp <- rgset[,!(rgset$SampleID=="50602_C")]

#check sizes
dim(rgset)
dim(rgset_nobadsamp)

#redo detP without bad sample
badDetP <- detectionP(rgset_nobadsamp)>0.01

#visual how many bad probes per sample
#first sum bad detP according to TRUE=1/FALSE=0 and put in data frame
nbaddetP_colsums <-as.data.frame(colSums(badDetP)) 
#add in sample_ID
nbaddetP_colsums$sample_id <-rgset_nobadsamp$SampleID
#plot in ggplot
ggplot(nbaddetP_colsums, aes(x=sample_id, y=colSums(badDetP))) +
  geom_col() +
  theme_classic() +
  labs(y="Number of failed probes") +
  rotate_x_text()

#visualize how many probes have 0,1,2, etc bad detectionP values
table(rowSums(badDetP))
#count number of probes with at least 1 bad detectionP 
nbadDetP_rowsums <-  sum(rowSums(badDetP)>=1)
nbadDetP_rowsums 
#5043 probes have at least one badDetP value
#check  number of good probes
sum(rowSums(badDetP)==0)
#calculate number of good probes in data
ngoodDetP <- rowSums(badDetP)==0
#lots of tasty probes remain -> keep only probes that are good in all samples(ie. no badDetP in a row)
#must convert to mset with processnoob and then remove bad probes as detectionP gives probe names not numbers (as given in manifest; additionally manifest contains many other probes that we dont care about)
```

Save data with bad samples removed for cell type deconvolution. 
The estimateCellCounts2 function only accepts rgsets.   
```{r save_unprocessed_rgset}
save(rgset_nobadsamp, file=here("output_data", "preprocessed_data", "2020-10-22_child_rgset_nobadsamp.Rdata"))
```

## Data preprocessing with Noob

Noob corrects for background using out-of-band probes (fluorescence of infinium 1 probes in opposite channel which they are designed for) and normalized-exponentional convolution.  / 

Normalize data using preprocessNoob - good for data where a large difference between groups is not expected.  
```{r noob}
#ratioconver=false results in genomicmethyl set
noob <- preprocessNoob(rgset_nobadsamp)
```


### Remove bad/unwanted probes using minfi. 

Do this first then remove cross-reactive probes (easier to write up in this order and order does not make a difference for this)

Remove bad probes from normalized data set.  
```{r remove_badprobes}
#check if probes in noob and ngoodDetP are in same order before applying ngoodDetP boolean matrix
#if not in same order the wrong probes will be removed
identical(rownames(noob), names(ngoodDetP))
#probes are in same order

#remove bad probes from data set by only keeping good probes
noob_goodp <- noob[ngoodDetP,] 

#examine size to see if correct number of probes  was removed (5043)
dim(noob)
dim(noob_goodp)
#remove 5043 probes
```

Remove probes with SNPS  
```{r remove_snps}
#make gmset from noob
gmset <- mapToGenome(noob_goodp)

#drop snps
gmset_nosnps <- dropLociWithSnps(gmset, snps = c("CpG"), maf = 0)
#create table of removed snps (should be all )
gmset_nosnpstable <- table(is.na(getSnpInfo(gmset_nosnps)$CpG_rs))

#check size
dim(gmset)
dim(gmset_nosnps)
#remove 15429 probes
```


Remove XY probes.  
```{r remove_xy}
#drop x and y 
annotation=getAnnotation(gmset_nosnps)

#check how many x and y probes are left
sum(annotation$chr %in% c("chrX","chrY"))
#10136 left

#get just probes that maps to autosomes
autosomes = annotation[!annotation$chr %in% c("chrX","chrY"), ]

#Remove XY
gmset_nosnps_noxy <- gmset_nosnps[getAnnotation(gmset_nosnps)[,4] %in% row.names(autosomes),]

#check that all x y probes are removed from set
sum(gmset_nosnps_noxy$chr %in% c("chrX","chrY"))

#check size
dim(gmset_nosnps)
dim(gmset_nosnps_noxy)
#remove 10957 probes

#remove objects we no longer need
remove(annotation)
remove(autosomes)
```



Remove cross-reactive probes based on Chen 2013.    
```{r remove_cross_reactive_probes}
#read in cross-reactive probe info from Chen (2013) paper
cr_probes <- read.csv("R:/Jones/People/Samantha Lee/Computational/CHILD/input_data/chen-non-specific-probes-Illumina450k.csv", header=TRUE)

cleaned_data <-  gmset_nosnps_noxy[!(rownames(gmset_nosnps_noxy) %in% cr_probes$TargetID), ] 

dim(gmset_nosnps_noxy)
dim(cleaned_data)
#remove 26378 probes
```


Get info for analysis from processed gmset and then save.  
```{r get_methinfo}
beta <- getBeta(gmset_nosnps_noxy)
mvalue <- getM(gmset_nosnps_noxy)
pData <- pData(gmset_nosnps_noxy)
sampleNames <- sampleNames(gmset_nosnps_noxy)
fData <- featureNames(gmset_nosnps_noxy)
annotated <- getAnnotation(gmset_nosnps_noxy)

#save(beta, mvalue, pData, sampleNames, fData, annotated,
#     file = "R:/Jones/People/Samantha #Lee/Computational/CHILD/workspaces/2020-01-14_childnoob_beta_mvalue_pData_sampleNames_fData_ann#otated.RData")
```

## Quality control of CHILD145 data  

### Beta density plot

Examine beta density before and after normalization - part of QC
```{r beta_density_before}
#before normalization
densityPlot(getBeta(rgset_nobadsamp))
```

```{r beta_density_after}
#after normalization
densityPlot(getBeta(noob))

#it's tighter now but there are still some methylated peaks with reduces height/slope
```

```{r beta_density_after_probe_removal}
#after bad probe removal, snp, xy, cross reactive probe removal
densityPlot(getBeta(gmset_nosnps_noxy))
```


Why are some left shifted in methylated peak? Meaghan thinks it could be nRBCs in cordblood. Colour by tissue to see if it's cordblood specific.  

```{r beta_density_coltissue}
densityPlot(beta, sampGroups = pData$Tissue)
```

Try preprocessing CBMCs (birth) and PBMCs (year 1) separately and then plot beta density to see if this fixes problem - probably not noob normalizes based on control probes.
```{r preprocess_tissues_sep}
#subset corb blood
cb_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="C"]
dim(cb_rgset)

#subset year 1 pbmcs
y1_rgset <- rgset_nobadsamp[,rgset_nobadsamp$Tissue=="P"]
dim(y1_rgset)

#noob preprocess cordbloo and year 1 pbmcs separately
cb_noob <- preprocessNoob(cb_rgset)
y1_noob <- preprocessNoob(y1_rgset)

#denisyt plot of CBMCs
densityPlot(getBeta(cb_noob))

#density plot of year1 PBMCs
densityPlot(getBeta(y1_noob), pal=brewer.pal(8, "Dark2")[2])

```

Left-shifted sample remain in cord blood - normalizing separately does not change. 

Cord blood samples have left shifted methylated peak. This is a signature of lots of nucleated RBCs. About six samples have strong nRBC signatures. Determine which of these samples it is.  

Subset betas to only cordblood. Then plot cord blood in "chunks" to identify samples.  
```{r find_nRBC_perps}
#use pData from  file = "R:/Jones/People/Samantha Lee/Computational/CHILD/workspaces/2020-01-10_childnoob_beta_batchcorr_mvalue_batchcorr_pData_sampleNames_fData_annotated.RData" as it had sample mixup corrected and bad samples removed

#subset cordblood out
bmiq_clean_cb <- bmiq_clean[, colnames(bmiq_clean) %in% rownames(subset(pdata, Tissue=="C"))]
#check size - expect 153
dim(bmiq_clean_cb)

#subset pdata
cb_pdata <- subset(pdata, Tissue=="C")
#check size - expect 153
dim(cb_pdata)

#plot 10 samples at a time as it's too much to plot at once

#samples 1-10
bmiq_clean10 <- bmiq_clean_cb[,1:10]

bmiq_cleanmelt10 <- bmiq_clean10 %>% reshape2::melt()

ggplot(bmiq_cleanmelt10, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#9341679051_R02C02, 9298768102_R02C02


#samples 11-20
bmiq_clean20 <- bmiq_clean_cb[,11:20]

bmiq_cleanmelt20 <- bmiq_clean20 %>% reshape2::melt()

ggplot(bmiq_cleanmelt20, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 


#samples 21-30
bmiq_clean30 <- bmiq_clean_cb[,21:30]

bmiq_cleanmelt30 <- bmiq_clean30 %>% reshape2::melt()

ggplot(bmiq_cleanmelt30, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#for sure 9297962087_R03C02
#maybe 9341679111_R06C02, 9343114048_R04C01, 9341679053_R05C02

#samples 31-40
bmiq_clean40 <- bmiq_clean_cb[,31:40]

bmiq_cleanmelt40 <- bmiq_clean40 %>% reshape2::melt()

ggplot(bmiq_cleanmelt40, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density")


#samples 41-50
bmiq_clean50 <- bmiq_clean_cb[,41:50]

bmiq_cleanmelt50 <- bmiq_clean50 %>% reshape2::melt()

ggplot(bmiq_cleanmelt50, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#9343114078_R03C02. 9297962140_R02C02


#samples 51-60
bmiq_clean60 <- bmiq_clean_cb[,51:60]

bmiq_cleanmelt60 <- bmiq_clean60 %>% reshape2::melt()

ggplot(bmiq_cleanmelt60, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 



#samples 61-70
bmiq_clean70 <- bmiq_clean_cb[,61:70]

bmiq_cleanmelt70 <- bmiq_clean70 %>% reshape2::melt()

ggplot(bmiq_cleanmelt70, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 


#samples 71:80
bmiq_clean80 <- bmiq_clean_cb[,71:80]

bmiq_cleanmelt80 <- bmiq_clean80 %>% reshape2::melt()

ggplot(bmiq_cleanmelt80, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 


#samples 81:90
bmiq_clean90 <- bmiq_clean_cb[,81:90]

bmiq_cleanmelt90 <- bmiq_clean90 %>% reshape2::melt()

ggplot(bmiq_cleanmelt90, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 


#samples 91:100
bmiq_clean100 <- bmiq_clean_cb[,91:100]

bmiq_cleanmelt100 <- bmiq_clean100 %>% reshape2::melt()

ggplot(bmiq_cleanmelt100, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#samples 101:110
bmiq_clean110 <- bmiq_clean_cb[,101:110]

bmiq_cleanmelt110 <- bmiq_clean110 %>% reshape2::melt()

ggplot(bmiq_cleanmelt110, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 


#samples 111:120
bmiq_clean120 <- bmiq_clean_cb[,111:120]

bmiq_cleanmelt120 <- bmiq_clean120 %>% reshape2::melt()

ggplot(bmiq_cleanmelt120, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#samples 121:130
bmiq_clean130 <- bmiq_clean_cb[,121:130]

bmiq_cleanmelt130 <- bmiq_clean130 %>% reshape2::melt()

ggplot(bmiq_cleanmelt130, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#9343114044_R05C02

#samples 131:140
bmiq_clean140 <- bmiq_clean_cb[,131:140]

bmiq_cleanmelt140 <- bmiq_clean140 %>% reshape2::melt()

ggplot(bmiq_cleanmelt140, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#samples 141:150
bmiq_clean150 <- bmiq_clean_cb[,141:150]

bmiq_cleanmelt150 <- bmiq_clean150 %>% reshape2::melt()

ggplot(bmiq_cleanmelt150, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#samples 151:153
bmiq_clean153 <- bmiq_clean_cb[,151:153]

bmiq_cleanmelt153 <- bmiq_clean153 %>% reshape2::melt()

ggplot(bmiq_cleanmelt153, aes(x=value, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_brewer(palette="Paired") +
  theme_classic() +
  labs(y="Density") 

#20216_C, 20064_C, 20488_C, 30230_C, 30212_C, 50154_C
#Only 20064 is early (~35 weeks)
```


Try colouring beta density left-shifted peaks with other metadata to see what's causing this pattern.
```{r betadensity_metadata}
#subset out cord data of bmiq_cleans
cb_bmiq_clean <- bmiq_clean[,colnames(bmiq_clean) %in% rownames(subset(pdata, Tissue == "C"))]
dim(cb_bmiq_clean)

#subset cord  blood pdata
cb_pdata <- subset(pdata, Tissue =="C")
dim(cb_pdata)

#remove replicates just for comparison on metadata
#later on below show that all replicates are similar
cb_pdata_sub <- cb_pdata[!duplicated(substr(cb_pdata$SampleID,1,5)), ]
dim(cb_pdata_sub) #144

#remove replicates in pdata
cb_bmiq_clean_sub <- cb_bmiq_clean[,colnames(cb_bmiq_clean) %in% rownames(cb_pdata)]
dim(cb_bmiq_clean_sub) #144


#subout metadata from metadata list
extrameta <- as.data.frame(metadata$extra_meta)
asthmapheno <- as.data.frame(metadata$`3YAsthmapheno_REEGLE`)
diabetes <- as.data.frame(metadata$diab_obesity_var)
greeness <- as.data.frame(metadata$greenness)
allmetrics <- as.data.frame(metadata$KoborCHILD_linkedallmetrics)

#convert sample_id to character
extrameta$sample_id <- as.character(extrameta$sample_id)
asthmapheno$sample_id <- as.character(asthmapheno$sample_id)
diabetes$sample_id <- as.character(diabetes$sample_id)
greeness$sample_id <- as.character(greeness$sample_id)
allmetrics$sample_id <- as.character(allmetrics$sample_id)


####remove samples from metadataextra if they are not in pdata

#get unique sample IDs from pdata
sample_ids <- unique(substr(cb_pdata_sub$SampleID, 1, 5))
length(sample_ids) #144 samples

#remove sample_id's that aren't in pdata
extrametasub <- extrameta[extrameta$sample_id %in% sample_ids,]
nrow(extrametasub) #144

asthmaphenosub <- asthmapheno[asthmapheno$sample_id %in% sample_ids,]
nrow(asthmaphenosub)#143

diabetessub <- diabetes[diabetes$sample_id %in% sample_ids,]
nrow(diabetessub) #144

greenesssub <- diabetes[greeness$sample_id %in% sample_ids,]
nrow(greenesssub) #144

allmetricsub <- diabetes[allmetrics$sample_id %in% sample_ids,]
nrow(allmetricsub) #144


######check if dnam and metadata are in same order as pdata

identical(colnames(cb_bmiq_clean_sub), rownames(cb_pdata_sub)) #true
identical(extrametasub$sample_id, substr(unique(cb_pdata_sub$SampleID), 1, 5)) #true
identical(diabetessub$sample_id, substr(unique(cb_pdata_sub$SampleID), 1, 5)) #true
identical(allmetricsub$sample_id, substr(unique(cb_pdata_sub$SampleID), 1, 5)) #true


#Are lefted shifted peaks related to method of delivery (mod)?
#populate cb_pdata with method of delivery info
i=1
for(i in 1:nrow(cb_pdata_sub))
  {
  cb_pdata$mod[i] =  extrameta[grep(substr(cb_pdata_sub$SampleID[i], 1, 5), extrameta$sample_id), "mod"]
  i = i+1
  }
       
#peaks related to method of delivery (mod)
densityPlot(cb_bmiq_clean_sub, sampGroups =  cb_pdata_sub$mod)
#all children wih left shifted peaks born vaginally

#Are left shifted peaks related to sex
#peaks related to sex?
densityPlot(cb_bmiq_clean_sub, sampGroups =  cb_pdata_sub$Sex)
#no relationship to sex

#Are the peaks related to gestational age?
#populate pdata with gestational age info
i=1
for(i in 1:nrow(cb_pdata_sub))
  {
  cb_pdata_sub$gestage_day[i] =  extrameta[grep(substr(cb_pdata_sub$SampleID[i], 1, 5), extrameta$sample_id),
                                           "b_gestage_d"]
  i = i+1
}

#melt bmiq_clean for plotting
cb_bmiq_cleanmelt <- cb_bmiq_clean_sub %>% melt()

#colour according to gestational age
#blue = premature, purple = normal, red = after 40 weeks, grey = NA
colour <- sapply(cb_pdata_sub$gestage_day, function(x) ifelse(is.na(x), "grey",
                                                          ifelse(x <= 259, "blue",
                                                                 ifelse( x >= 260 & x <= 280, "purple" , 
                                                                         ifelse( x >= 281, "red", "grey")))))
  
  
#colour density plot according to gestational age
ggplot(cb_bmiq_cleanmelt, aes(x=value, na.rm=FALSE, col=as.factor(Var2))) + 
  geom_density(size=1) +
  scale_color_manual(values=colour) +
  theme_classic() +
  labs(y="Density") 
  theme(legend.position = "none")

```

#### Examine cord blood methylation at IDOL cord blood CpGs

```{r idol_cb_cpgs_methylation}
library(FlowSorted.CordBloodCombined.450k)
data("IDOLOptimizedCpGsCordBlood")


#subset for idol probes
idol_cb_meth <- cb_beta[rownames(cb_beta) %in% IDOLOptimizedCpGsCordBlood,]

#examine
head(idol_cb_meth)

#column means quick box plot
boxplot(colMeans(idol_cb_meth))


#column medians
colmeans <- as.data.frame(colMeans(idol_cb_meth), row.names = colnames(idol_cb_meth))
colmeans$type <- "cb"

#sub for outlier labelling
colmeans_sub <- colmeans %>% subset(`colMeans(idol_cb_meth)` > 0.67)

#good boxplot
ggplot(colmeans, aes(y=colmeans[,1], x=type)) +
  geom_boxplot(stat = "boxplot", 
               position = "dodge2") +
  theme_bw() +
  theme(panel.border = element_blank()) +
  ggrepel::geom_text_repel( 
                           data = colmeans_sub, 
                           aes(x = type,  y = `colMeans(idol_cb_meth)`),
                           label=rownames(colmeans_sub))





#column medians quick box plot
boxplot(colMedians(idol_cb_meth))

#column medians
colmedians <- as.data.frame(colMedians(idol_cb_meth), row.names = colnames(idol_cb_meth))
colmedians$type <- "cb"

#sub for outlier labelling
colmedians_sub <- colmedians %>% subset(`colMedians(idol_cb_meth)` > 0.75)

#good boxplot
ggplot(colmedians, aes(y=colmedians[,1], x=type)) +
  geom_boxplot(stat = "boxplot", 
               position = "dodge2") +
  theme_bw() +
  theme(panel.border = element_blank()) +
  ggrepel::geom_text_repel( 
                           data = colmedians_sub, 
                           aes(x = type,  y = `colMedians(idol_cb_meth)`),
                           label=rownames(colmedians_sub))


#left shifted samples
left <- c("20216_C", "20064_C", "20488_C", "30230_C", "30212_C", "50154_C")

#get participant ids from pdata that match with left shifted sample IDs
rownames(cb_pData[cb_pData$SampleID %in% left,])

```





#### Genetic effects on beta density

Are the left-shited methylated peaks due to genetic differences. Dont have genotyping data but do have first 10 PCs. Examing group of samples based on first two PCs.

```{r import_genotyping_PCs}
#import PCs
#contains PCs from ENTIRE child cohort
genotype_pcs <- read.csv("R:\\Jones\\People\\Samantha Lee\\Computational\\CHILD\\other\\CHILD_subjects_Qced_first10PCS_Duan.csv", 
                         header=TRUE)

#subset out cordblood data from pData
cb_pData <- subset(pData, Tissue =="C")
dim(cb_pData)

#convert genotyping participant ID to charactger
genotype_pcs$FID <- as.character(genotype_pcs$FID)

#subset genotyping PCs for CHILD145 data
genopc_sub <- genotype_pcs[genotype_pcs$FID %in% substr(cb_pData$SampleID, 1, 5), ]
dim(genopc_sub)

```

```{r plot_genotyping_PCs}
ggplot(genopc_sub, aes(x=PC1, y=PC2)) +
  geom_point() +
  theme_classic() +
  ggrepel::geom_label_repel(aes(label=FID))

```

Methylated shift is not due to genetic effects.  

### MDS plot  

MDS and PCA are both dimension reduction techniques but have different properties. 

PCA plots the original vectors in n-dimensional space. The data are projected onto the directions in the data with the most variance. Hence the “spread” of the data is roughly conserved as the dimensionality decreases.  

The input to MDS is the pairwise distances between points. The output of MDS is a two- or three-dimensional projection of the points where distances are preserved.  

Minfi's MDS plot calculates Euclidean distance between samples using the numPositions most variable CpG positions. These distances are then projected into a 2-d plane using classical multidimensional scaling transformation.  

Make MDS plot to examine data - part of QC.   
```{r mds_plot}
#do MDS plot manually based on code from minfi - allows plotting with ggplot

#using commands that mdsplot uses to calculate mds distances
beta_ordered <- order(rowVars(beta), decreasing = TRUE)[seq_len(1000)] 
beta_ordered_dist <- dist(t(beta[beta_ordered, ]))
beta_dist_naomit <- na.omit(beta_ordered_dist )
fit <- cmdscale(beta_dist_naomit)

#convert to dataframe for plotting
fit_df <- as.data.frame(fit)
#add in tissue information
fit_df$tissue <- pData$Tissue
fit_df$samplename <- pData$SampleID

#plot
mds <- ggplot(fit_df, aes(x=fit[,1], y=fit[,2])) + 
  geom_point(size=4, shape=21, alpha=0.7, aes(fill=tissue))+
  theme_classic() +
  labs(x="Distance 1", y="Distance 2", title = "Multidimensional scaling plot") 
  #ggrepel::geom_label_repel(data=fit_df, stat="identity", aes(label=samplename))

mds

#tissue mix up for sample 20113 -> relabel
pData$SampleID[5] <- "20113_P"
pData$Tissue[5] <- "P"
pData$SampleID[6] <- "20113_C"
pData$Tissue[6] <- "C"

#redo mds plot with relabelled samples
#using commands that mdsplot uses to calculate mds distances
beta_ordered <- order(rowVars(beta), decreasing = TRUE)[seq_len(1000)] 
beta_ordered_dist <- dist(t(beta[beta_ordered, ]))
beta_dist_naomit <- na.omit(beta_ordered_dist )
fit <- cmdscale(beta_dist_naomit)

#convert to dataframe for plotting
fit_df <- as.data.frame(fit)
#add in tissue information
fit_df$tissue <- pData$Tissue
fit_df$samplename <- pData$SampleID

#plot
mds2 <- ggplot(fit_df, aes(x=fit[,1], y=fit[,2])) + 
  geom_point(size=4, shape=21, alpha=0.7, aes(fill=tissue))+
  theme_classic() +
  labs(x="Distance 1", y="Distance 2", title = "Multidimensional scaling plot") 

mds2

rm(beta_dist_naomit, beta_ordered, beta_ordered_dist, fit, fit_df)
```

### QC Plot  

Minfi's QC plot plots points as a function of the methylated and unmethylated values.  Points that have low methylated or unmethylated values will fall below QC cut off line (set at 10.5). This does not necessarily mean that samples are bad - futher investigation is needed to determine why these samples fall below the cut off line before determining if they should be discarded.  

Make QC plot - part of data QC.  
```{r qc_plot}
#use methyl or genomicmethyl data
#added na.omit, but may need to delete later
unmeth_medians <- log2(colMedians(na.omit(getUnmeth(gmset_nosnps_noxy))))
meth_medians <- log2(colMedians(na.omit(getMeth(gmset_nosnps_noxy))))
qc_data <- DataFrame(mMed = meth_medians, uMed = unmeth_medians)
rownames(qc_data) <- colnames(gmset_nosnps_noxy)
qc_data <- as.data.frame(qc_data)
qc_data$Sample_ID <- pData$Sample_ID
qc_data$tissue <- pData$Tissue
qc_data$sex <- pData$Sex
qc_data$chip <- pData$Slide
qc_data$run <- pData$Run

#can change badsamplecutoff
badSampleCutoff = 10.5
meds <- (qc_data$mMed + qc_data$uMed)/2
whichBad <- which((meds < badSampleCutoff))

#graph it
qcplot<- ggplot(qc_data, aes(x=mMed, y=uMed)) + 
  geom_point(size=4, shape=21, aes(fill=as.factor(run))) +
  labs(x="Methylated median", y="Unmethylated median", title="QC Plot") +
  geom_abline(intercept=badSampleCutoff * 2, slope=-1, linetype = "dashed") +
  theme_classic() 
#theme(legend.position="none") 
#run 1 is different from runb

qcplot
#samples from run number 2 fall below cut off line
#Run 2 has lower overall intensity because Meaghan and Julie (Mostly Meaghan) accidentally inverted some of the reagents in the staining step which affects the intensities values (as per correspondance with Illumina) -> samples are still good!. 
```

Colour beta density according to run and chip

```{r colour_beta_density_run_chip}

#run 
densityPlot(cb_beta, sampGroups =  cb_pData$Run)


#custome colours 
mypal <- c("deepskyblue4", "deeppink3", "darkorchid3", "darkorange1", "cyan3",
           "gray43", "firebrick2", "gray48", "green4", "indianred3",
           "lightseagreen", "orangered3", "olivedrab3", "mediumpurple3", "seagreen3",
           "sienna1", "slateblue", "royalblue1", "red", "purple", 
           "blue", "springgreen1", "tomato", "yellow", "black")

#chip
densityPlot(cb_beta, sampGroups = cb_pData$Sentrix_ID, legend=FALSE, pal=mypal)


mypal2 <- c("blue", "black", "yellow", "green4", "red", "purple", 
            "gray69", "deeppink", "cyan", "darkorange1", "springgreen", "lawngreen")

#row
densityPlot(cb_beta, sampGroups = cb_pData$Sentrix_Position, pal=mypal2)
```




## Duplicate sample removal

Some samples from the same particpant were run multiple times. Plot the beta density to see if they are similar then randomly choose which sample to choose.

```{r dup_sample_removal}
#samples with repeat measurements: 20367_C (4x), 40060_C (4x), 40083_C (4x)

#get rownums of 20367
dups <- grep("20367_C", pData$SampleID)
#get rownames of 20367
dups_row <- rownames(pData[dups,])

#density plot of 20367
densityPlot(beta[, colnames(beta) %in% dups_row], 
            sampGroups = colnames(beta[, colnames(beta) %in% dups_row]), legend = FALSE)



#################### SAMPLE SELECTION #######################

#these should have set.seed() so same sample always selected
#in this case selected sample is specified in code
#change in future

#select a ranomd sample from dups_row to include in analysis
sample(1:4, 1) #selected sample number 2 
dups_row[2] #use this sample in analysis: "9343114078_R06C01" (20367_C_Rep3_2)



#get rownums of 40060_C  
dups <- grep("40060_C", pData$SampleID)
#get rownames of 40060_C  
dups_row <- rownames(pData[dups,])

#density plot of 40060_C  
densityPlot(beta[, colnames(beta) %in% dups_row], 
            sampGroups = colnames(beta[, colnames(beta) %in% dups_row]), legend = FALSE)


#select a ranomd sample from dups_row to include in analysis
sample(1:4, 1) #select sample number 2 
dups_row[3] #use this sample in analysis: "9341679111_R02C02" (40060_C_Rep1_3)



#get rownums of 40083_C  
dups <- grep("40083_C", pData$SampleID)
#get rownames of 40083_C  
dups_row <- rownames(pData[dups,])

#density plot of 40083_C  
densityPlot(beta[, colnames(beta) %in% dups_row], 
            sampGroups = colnames(beta[, colnames(beta) %in% dups_row]), legend = FALSE)

#select a ranomd sample from dups_row to include in analysis
sample(1:4, 1) #select sample number 2 
dups_row[2] #use this sample in analysis: "9343114078_R05C01" (40083_C_Rep2_2)
```

Remove bad samples before batch correction as having multiple samples from same particpant may affect variance.  

```{r remove_dups}

#make list of samples to remove from beta and pData
dups_rm <-c("9298768102_R06C01", "9341679111_R05C02", "9298768023_R03C02",
            "9341679076_R06C02", "9297962089_R06C02", "9298768023_R02C02",
            "9341679097_R02C02", "9341679114_R01C02", "9298768023_R06C01")

#remove replicates from pData                        
pData_nodups <- pData[!rownames(pData) %in% dups_rm, ]
#check that 9 samples were removed
dim(pData)
dim(pData_nodups)


#remove replicates from beta matrix
beta_nodups <- beta[,!colnames(beta) %in% dups_rm]
#check that 9 samples were removed
dim(beta)
dim(beta_nodups)
min(beta_nodups)
max(beta_nodups)

#remove duplicates from mvalues
mvalue_nodups <- mvalue[,!colnames(mvalue) %in% dups_rm]
dim(mvalue)
dim(mvalue_nodups)
min(mvalue_nodups)
max(mvalue_nodups)

```


### Heat Scree Plot and PCA heatmap function

Set up heat scree plot function
```{r heat_scree_plot}
#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot <- function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #no continuous variables here!
  
  #Conduct spearman correlation 
  #cor_PC_meta <- lapply(1:ncol(meta_continuous), 
  #                      function(covar) sapply(1:ncol(Loadings), 
  #                      function(PC) (cor.test(Loadings[,PC],
  #                                             as.numeric(meta_continuous[,covar]),
  #                                             alternative = "two.sided", method="spearman",
  #                                             na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  #names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  #cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  #allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- aov_PC_meta[,2:ncol(aov_PC_meta)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Create column to name rows accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}


```

### Batch correction of child 145 data

Make model matrix for batch correction. This invovles changing pData columns to factors as they are categorical not continuous. Because we are not correcting for covariates the model matrix will simply be the intercept. 
```{r model_matrix}
pData_nodups$Run <- as.factor(pData_nodups$Run)
pData_nodups$Sentrix_ID <- as.factor(pData_nodups$Sentrix_ID)
#pull out row from sentrix position then set to factor
pData_nodups$row <- substr(pData_nodups$Sentrix_Position, 1, 3)
pData_nodups$row <- as.factor(pData_nodups$row)
pData_nodups$Sex <- as.factor(pData_nodups$Sex)
pData_nodups$Group <- as.factor(pData_nodups$Group)
pData_nodups$Atopy <- as.factor(pData_nodups$Atopy)
pData_nodups$Wheeze <- as.factor(pData_nodups$Wheeze)
pData_nodups$Tissue <- as.factor(pData_nodups$Tissue)

#run batch correction in the order of (1) run, (2) row, (chip)

#create a model matrix using pData
#this generates intercepts only since we are not adding in covariates
mod = model.matrix(~1, data=pData_nodups)
```

Examine heat scree plot before any batch correction.  
```{r heat_scree_before}
uncor.dat <- t(scale(t(mvalue_nodups)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
#only have categorical
meta_categorical<-pData_nodups[,c("Run", "Sentrix_ID", "row" ,"Sex", "Group", "Atopy", "Wheeze", "Tissue")] 

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```

Batch correction should be done in the following order: (1) run, (2) row, then (3) chip.
Batch correction for run:  
```{r batch_run}
#can't have NAs for this function -> already removed them
combat_run <- ComBat(dat=mvalue_nodups, batch=pData_nodups$Run, mod = mod) 

#PCA
uncor.dat <- t(scale(t(combat_run)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
meta_categorical<-pData_nodups[,c("Run", "Sentrix_ID", "row" ,"Sex", "Group", "Atopy", "Wheeze", "Tissue")] 
heat_scree_plot(Loadings, Importance, Num, Order)

```


Batch correction for row:
```{r batch_row}

#can't have NAs for this function -> already removed them
combat_row <- ComBat(dat=combat_run, batch=pData_nodups$row, mod = mod) 

#PCA
uncor.dat <- t(scale(t(combat_row)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
meta_categorical<-pData_nodups[,c("Run", "Sentrix_ID", "row" ,"Sex", "Group", "Atopy", "Wheeze", "Tissue")] 
heat_scree_plot(Loadings, Importance, Num, Order)
```

Batch correction for chip:
```{r batch_chip}
#can't have NAs for this function -> already removed them
combat_chip<- ComBat(dat=combat_row, batch=pData_nodups$Sentrix_ID, mod = mod) 

#PCA
uncor.dat <- t(scale(t(combat_chip)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance<-vars/sum(vars)

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:10)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
meta_categorical<-pData_nodups[,c("Run", "Sentrix_ID", "row" ,"Sex", "Group", "Atopy", "Wheeze", "Tissue")] 
heat_scree_plot(Loadings, Importance, Num, Order)

```

Rename and then save processed and normalized data for analysis.
```{r save_data}
mval_batchcorr <- combat_chip
min(mval_batchcorr)
max(mval_batchcorr)

beta_batchcorr <- lumi::m2beta(mval_batchcorr)
min(beta_batchcorr)
max(beta_batchcorr)

#save mvalues, pdata, and annotation
save(mval_batchcorr, pData_nodups, annotated,
     file = "R:/Jones/People/Samantha Lee/Computational/CHILD/workspaces/CHILD_batchcorrected_data/2020-06_12_CHILD_noduplicates_batchcorrected_mvalue_pData_annotaed.RData")
```




