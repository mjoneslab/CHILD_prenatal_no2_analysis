---
title: "CHILD year one cell types vs pc correction"
author: "SL"
date: "19/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(tidyverse)
library(minfi)
library(pbapply)
library(limma)
library(rgr) #for log centred ratio transfromation
library(factoextra)
library(GGally)
library(here)
```

Load betas  
```{r load_betas, message=FALSE, warning=FALSE}
load("R:/Jones/People/Samantha Lee/Projects/CHILD/CHILD_air_pollution/output_data/preprocessed_data/2021-01_14_CHILD_preprocessed_betas_pdata_annotation.Rdata")
```

Load CHILD145 deconvolution data. This deconvolution does not include granulocytes as granulocytes are not expected.
```{r load_deconvolution, message=FALSE, warning=FALSE}
load(here("output_data", "deconvolution", "2020-11-10_CBMC_PBMC_deconvolution.RData"))
```


## Get year one DNAm changes 

Subset out age one and cord blood pData. Then subset for samples that have data available at both time points. 
```{r sub_pdata}
cb_pdata <- subset(pdata_nodups, Tissue == "C")
dim(cb_pdata) # 144  17

#subset out age one pdata
y1_pdata <- subset(pdata_nodups, Tissue == "P")
dim(y1_pdata) #145  17

#year one data has one individual that is missing birth data
#remove this individual
y1_pdata_sub <- y1_pdata[y1_pdata$Sample_Label %in% cb_pdata$Sample_Label, ]
dim(y1_pdata_sub) # 144  17
```

Subset out cord blood betas and year one betas. Then subset year one data for individuals that have DNAm measured at both time points. 
```{r subset_blood_betas}

#subset pData into CBMCs (cord blood)
#these children have data at both time points
cb_betas <- betas[,colnames(betas) %in% rownames(cb_pdata)]
#check size of cord blood data
dim(cb_betas) # 424644    144
min(cb_betas) # 0.002973941
max(cb_betas) # 0.9980669

#check if cord blood DNAm samples are in same order in cord blood pdata
identical(colnames(cb_betas), rownames(cb_pdata)) #true
#rename columns of cb_betas
colnames(cb_betas) <- cb_pdata$Sample_Label


#subset out cordblood samples from beta matrix
y1_betas <- betas[,colnames(betas) %in% rownames(y1_pdata_sub)]
#check size of year one data
dim(y1_betas) # 424644    144
min(y1_betas) #0.002650193
max(y1_betas) #0.9983506

#check if cord blood DNAm samples are in same order in cord blood pdata
identical(colnames(y1_betas), rownames(y1_pdata_sub)) #true
#rename columns of cb_betas
colnames(y1_betas) <- y1_pdata_sub$Sample_Label

#check if cord blood samples and year one samples are in same order
identical(colnames(cb_betas), colnames(y1_betas))
```

Subtract batch corrected cord blood DNAm data from batch corrrected year one DNAm data. 
```{r diff_betas}
#check if cord blood samples and year one samples are in same order
identical(colnames(cb_betas), colnames(y1_betas))

#subtract cord blood DNAm from year one DNAm ("difference betas")
diff_betas <- y1_betas - cb_betas
#check size of difference betas
dim(diff_betas) # 424644    144
min(diff_betas) # -0.9793121 
max(diff_betas) # 0.9797916
```

Remove duplicates from cord blood deconvolution data then rename rows with pdata sample label.
```{r remove_dups_cb_cellcounts}
#convert deconvolution data to dataframe
child_fscbc_ecc2_cb_df <- as.data.frame(child_fscbc_ecc2_cb$counts)
#check size
dim(child_fscbc_ecc2_cb_df) # 153 6

#make list of samples to remove from beta and pData
dups_rm <-c("9298768102_R06C01", "9341679111_R05C02", "9298768023_R03C02",
            "9341679076_R06C02", "9297962089_R06C02", "9298768023_R02C02",
            "9341679097_R02C02", "9341679114_R01C02", "9298768023_R06C01")

#remove replicates from cell type estimates                      
child_fscbc_ecc2_cb_df_nodups <-
  child_fscbc_ecc2_cb_df[!rownames(child_fscbc_ecc2_cb_df) %in% dups_rm, ]

#check that 9 samples were removed
dim(child_fscbc_ecc2_cb_df_nodups) # 144   6


#check if cord blood cell counts are in the same order as pdata
identical(rownames(child_fscbc_ecc2_cb_df_nodups), rownames(cb_pdata)) #true
#rename rows of cord blood cell counts to sample label
rownames(child_fscbc_ecc2_cb_df_nodups) <- cb_pdata$Sample_Label


#rename cord blood cell counts columns
colnames(child_fscbc_ecc2_cb_df_nodups) <- paste("cb", colnames(child_fscbc_ecc2_cb_df_nodups), sep=".")
```


Convert age one cell counts to data frame and rename rows to pdata sample label.
```{r ageone_cellcounts}
#convert to dataframe
child_fscbc_ecc2_y1_df <- as.data.frame(child_fscbc_ecc2_y1)
#check size
dim(child_fscbc_ecc2_y1_df) # 145 5

#subset for samples that have data at both time points
child_fscbc_ecc2_y1_df_sub <- 
  child_fscbc_ecc2_y1_df[rownames(child_fscbc_ecc2_y1_df) %in% rownames(y1_pdata_sub), ]
#check size
dim(child_fscbc_ecc2_y1_df_sub) # 144 5


#check if year one cell counts are in the same order as pdata
identical(rownames(child_fscbc_ecc2_y1_df_sub), rownames(y1_pdata_sub)) #true
#rename rows of cord blood cell counts to sample label
rownames(child_fscbc_ecc2_y1_df_sub) <- y1_pdata_sub$Sample_Label


#rename year one cell counts columns
colnames(child_fscbc_ecc2_y1_df_sub) <- paste("y1", 
                                              substr(colnames(child_fscbc_ecc2_y1_df_sub), 8, 13), 
                                              sep=".")
```

Combine cord blood and year one cell counts into one data frame. This combined data frame is for correcting for cell types directly. 
```{r combined_cellcounts}
#check that cord blood and year one cell counts are in the same order
identical(rownames(child_fscbc_ecc2_cb_df_nodups), rownames(child_fscbc_ecc2_y1_df_sub)) #true

#combine cell counts (ccc)
ccc <- cbind(child_fscbc_ecc2_cb_df_nodups, child_fscbc_ecc2_y1_df_sub)
dim(ccc) # 144 11
head(ccc)
```

Make another combined cell counts data frame. But this time, perform CLR on CBMCs and PBMC before combining and doing PCA.
```{r combined_cellcounts_pca}
#check how many negatives in cord blood
sum(child_fscbc_ecc2_cb_df_nodups <= 0) #0

#clr
cb_celltypes_clr <- clr(as.matrix(child_fscbc_ecc2_cb_df_nodups))

#check for NAs or inf
#these will occur if zeroes or negatives existed in cell tyoe estimates
sum(is.na(cb_celltypes_clr)) #0
sum(is.infinite(cb_celltypes_clr)) #0

#check how many negatives
sum(child_fscbc_ecc2_y1_df <= 0) #0

#clr
y1_celltypes_clr <- clr(as.matrix(child_fscbc_ecc2_y1_df_sub))

#check for NAs or inf
#these will occur if zeroes or negatives existed in cell tyoe estimates
sum(is.na(y1_celltypes_clr)) #0
sum(is.infinite(y1_celltypes_clr)) #0

#combine cell counts (ccc_pca)
ccc_pca <- cbind(cb_celltypes_clr, y1_celltypes_clr)
dim(ccc_pca) # 144 11
head(ccc_pca)
```


```{r celltype_correction}
#fit a linear model for each probe in the matrix
#no granulocytes

#fit a linear model for each probe in the matrix using cell type PCs as covariates
celltype_design <- model.matrix(~ cb.NK + cb.Bcell + cb.Mono + cb.CD8T + cb.nRBC + cb.CD4T
                                + y1.CD4T + y1.CD8T + y1.Mono + y1.NK + y1.Bcell,
                              data=ccc)

#fit methylation to batch variables then get residuals
celltype_fit <-  lmFit(diff_betas, celltype_design)

#get residuals 
celltype_residuals <- residuals(celltype_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(celltype_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
celltype_adj_betas <- celltype_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(celltype_residuals), 
                                     ncol=ncol(celltype_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(celltype_adj_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(celltype_adj_betas) # 1.157661 
min(celltype_adj_betas) # -0.2376358

# adj.betas contains values less than 0 and greater than 1 
# These need to be fixed because they result in NAs during conversion to M values
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
message("Setting floor to lowest measurement above 0,\n",
        "and ceiling to highest measurement below 1 for M value conversion")
celltype_adj_betas[celltype_adj_betas > 1] <- max(celltype_adj_betas[celltype_adj_betas < 1])
celltype_adj_betas[celltype_adj_betas < 0] <- min(celltype_adj_betas[celltype_adj_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(celltype_adj_betas) # 0.999999
min(celltype_adj_betas) # 1.07643e-06

```


Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
celltype_adj_mvals <- lumi::beta2m(celltype_adj_betas)

#check max/min of mvals
max(celltype_adj_mvals)
min(celltype_adj_mvals)
```



Drop CD4T cells to prevent overfitting
```{r celltype_correction_noCD4T}
#fit a linear model for each probe in the matrix
#no granulocytes

#fit a linear model for each probe in the matrix using cell type PCs as covariates
celltype9_design <- model.matrix(~ cb.NK + cb.Bcell + cb.Mono + cb.CD8T + cb.nRBC +
                                 y1.CD8T + y1.Mono + y1.NK + y1.Bcell,
                              data=ccc)

#fit methylation to batch variables then get residuals
celltype9_fit <-  lmFit(diff_betas, celltype9_design)

#get residuals 
celltype9_residuals <- residuals(celltype9_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(celltype9_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
celltype9_adj_betas <- celltype9_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(celltype9_residuals), 
                                     ncol=ncol(celltype9_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(celltype9_adj_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(celltype9_adj_betas) # 1.157661 
min(celltype9_adj_betas) # -0.2376358

# adj.betas contains values less than 0 and greater than 1 
# These need to be fixed because they result in NAs during conversion to M values
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
message("Setting floor to lowest measurement above 0,\n",
        "and ceiling to highest measurement below 1 for M value conversion")
celltype9_adj_betas[celltype9_adj_betas > 1] <- max(celltype9_adj_betas[celltype9_adj_betas < 1])
celltype9_adj_betas[celltype9_adj_betas < 0] <- min(celltype9_adj_betas[celltype9_adj_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(celltype9_adj_betas) # 0.999999
min(celltype9_adj_betas) # 1.07643e-06

```


Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
celltype9_adj_mvals <- lumi::beta2m(celltype9_adj_betas)

#check max/min of mvals
max(celltype9_adj_mvals)
min(celltype9_adj_mvals)
```


## Principle component analysis


Principle component analysis of combined cell counts.
```{r pca}
#pca
ccc_pca2 <- prcomp(ccc_pca, scale. = TRUE)

#scree plot
factoextra::fviz_eig(ccc_pca2, ncp=15) # take first 9 PCs

#convert to dataframe
ccc_pcs <- as.data.frame(ccc_pca2$x)

#examine grouping of pcs
GGally::ggpairs(ccc_pcs, columns=1:11, progress=FALSE) 
```




Cell type correction using 11 principle components.
```{r pc11_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
pc11_design <- model.matrix(~ PC1  + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10 + PC11, 
                              data=ccc_pcs)

#fit methylation to batch variables then get residuals
pc11_fit <-  lmFit(diff_betas, pc11_design)

#get residuals 
pc11_residuals <- residuals(pc11_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(pc11_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
adj_pc11_betas <- pc11_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(pc11_residuals), 
                                     ncol=ncol(pc11_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(adj_pc11_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(adj_pc11_betas) #1.182634
min(adj_pc11_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
adj_pc11_betas[adj_pc11_betas > 1] <- max(adj_pc11_betas[adj_pc11_betas < 1])
adj_pc11_betas[adj_pc11_betas < 0] <- min(adj_pc11_betas[adj_pc11_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(adj_pc11_betas) # 0.9999994
min(adj_pc11_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
adj_pc11_mvals <- lumi::beta2m(adj_pc11_betas)

#check max/min of mvals
max(adj_pc11_mvals)
min(adj_pc11_mvals)
```


Cell type correction using 10 principle components.
```{r pc10_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
pc10_design <- model.matrix(~ PC1  + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10, 
                              data=ccc_pcs)

#fit methylation to batch variables then get residuals
pc10_fit <-  lmFit(diff_betas, pc10_design)

#get residuals 
pc10_residuals <- residuals(pc10_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(pc10_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
adj_pc10_betas <- pc10_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(pc10_residuals), 
                                     ncol=ncol(pc10_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(adj_pc10_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(adj_pc10_betas) #1.182634
min(adj_pc10_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
adj_pc10_betas[adj_pc10_betas > 1] <- max(adj_pc10_betas[adj_pc10_betas < 1])
adj_pc10_betas[adj_pc10_betas < 0] <- min(adj_pc10_betas[adj_pc10_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(adj_pc10_betas) # 0.9999994
min(adj_pc10_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
adj_pc10_mvals <- lumi::beta2m(adj_pc10_betas)

#check max/min of mvals
max(adj_pc10_mvals)
min(adj_pc10_mvals)
```



Cell type correction using 9 principle components.
```{r pc9_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
pc9_design <- model.matrix(~ PC1  + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9, 
                              data=ccc_pcs)

#fit methylation to batch variables then get residuals
pc9_fit <-  lmFit(diff_betas, pc9_design)

#get residuals 
pc9_residuals <- residuals(pc9_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(pc9_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
adj_pc9_betas <- pc9_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(pc9_residuals), 
                                     ncol=ncol(pc9_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(adj_pc9_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(adj_pc9_betas) #1.182634
min(adj_pc9_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
adj_pc9_betas[adj_pc9_betas > 1] <- max(adj_pc9_betas[adj_pc9_betas < 1])
adj_pc9_betas[adj_pc9_betas < 0] <- min(adj_pc9_betas[adj_pc9_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(adj_pc9_betas) # 0.9999994
min(adj_pc9_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
adj_pc9_mvals <- lumi::beta2m(adj_pc9_betas)

#check max/min of mvals
max(adj_pc9_mvals)
min(adj_pc9_mvals)
```



Cell type correction using 8 principle components.
```{r pc10_correction}
#fit a linear model for each probe in the matrix using cell type PCs as covariates
pc8_design <- model.matrix(~ PC1  + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8, 
                              data=ccc_pcs)

#fit methylation to batch variables then get residuals
pc8_fit <-  lmFit(diff_betas, pc8_design)

#get residuals 
pc8_residuals <- residuals(pc8_fit, diff_betas) 

#check if colnames of cordblood residuals and cord blood batch corrected betas are the same
identical(colnames(pc8_residuals), colnames(diff_betas))

#add residuals of each regression model to the mean methyaltion value of each probe (mean across samples)
#this gives the "corrected" methylation data
adj_pc8_betas <- pc8_residuals + matrix(apply(diff_betas, 1, mean), 
                                     nrow=nrow(pc8_residuals), 
                                     ncol=ncol(pc8_residuals))


#check how unadjusted and adjusted betas compares
#batch corrected
print(diff_betas[1:5,1:5])
#cell type PC adjusted
print(adj_pc8_betas[1:5,1:5])
```


Adjust beta values so that values >1 or <0 are now equal to largest number below 1 and smallest number below 0, respectively. 
```{r adjust_beta_range}
#check that adjusted betas do not fall below 0 or above 1
max(adj_pc8_betas) #1.182634
min(adj_pc8_betas) #-0.1585874

# PC adjusted betas contains values less than 0 and greater than 1 
# Replace values higher than 1 with the largest number closest to 1
# Replace values lower than 0 with the lowest non-negative number
adj_pc8_betas[adj_pc8_betas > 1] <- max(adj_pc8_betas[adj_pc8_betas < 1])
adj_pc8_betas[adj_pc8_betas < 0] <- min(adj_pc8_betas[adj_pc8_betas > 0])

#check that adjusted betas do not fall below 0 or above 1
max(adj_pc8_betas) # 0.9999994
min(adj_pc8_betas) # 8.904845e-06
```

Convert cell type corrected beta values back to m-values for further statistical analysis.  
```{r beta2m}
#convert beta values to m values
adj_pc8_mvals <- lumi::beta2m(adj_pc8_betas)

#check max/min of mvals
max(adj_pc8_mvals)
min(adj_pc8_mvals)
```



### Heat scree plots for comparing correction efficiency

Set up heat scree plot function
```{r heat_plot}

#initialize the heatplot function 
#outputs heatmap of PCs
heat_scree_plot <- function(Loadings, Importance, Num, Order){

  ######### adjust according to importance of first PC #########
  adjust <- 1-Importance[1]
  pca_adjusted <- Importance[2:length(Importance)]/adjust
  pca_df <- data.frame(adjusted_variance = pca_adjusted, 
                      PC = seq(1:length(pca_adjusted)))
  
  ######### Scree plot #########
  
  #plot variance that each adjusted PC accounts for 
  scree <- ggplot(pca_df[which(pca_df$PC<=Num),],aes(PC,adjusted_variance)) + 
    geom_bar(stat = "identity",color="black",fill="grey") +
    theme_bw()+
    theme(axis.text = element_text(size =12),
          axis.title = element_text(size =15),
          plot.margin=unit(c(1,1.5,0.2,2.25),"cm"))+ylab("Variance") +
    scale_x_continuous(breaks = seq(1,Num,1))
  
  ######### Heat map of variance in each variable explained by PCs ######### 
  
  #correlate metadata (variables) with PCS
  #Run anova of each PC on each meta data variable
  
  ### Categorical variables ###
  
  #Run ANOVA on each PC
  aov_PC_meta <- lapply(1:ncol(meta_categorical), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) summary(aov(Loadings[,PC]~
                                                 meta_categorical[,covar]))[[1]]$"Pr(>F)"[1]))
  
  #set names according to names of categorical variables
  names(aov_PC_meta) <- colnames(meta_categorical)
  #create matrix from list
  aov_PC_meta <- do.call(rbind, aov_PC_meta)
  
  
  ### Continuous variables ### 
  
  #Conduct spearman correlation 
  cor_PC_meta <- lapply(1:ncol(meta_continuous), 
                        function(covar) sapply(1:ncol(Loadings), 
                        function(PC) (cor.test(Loadings[,PC],
                                               as.numeric(meta_continuous[,covar]),
                                               alternative = "two.sided", method="spearman",
                                               na.action=na.omit, exact=FALSE)$p.value)))
  
  #rename according to names of continuous variables
  names(cor_PC_meta)<-colnames(meta_continuous)
  #create matrix from list
  cor_PC_meta<-do.call(rbind, cor_PC_meta)
  
  
  ### Prepare continous and categorical data for heat map ###
  
  #combine as df
  allvar_PC <- as.data.frame(rbind(aov_PC_meta, cor_PC_meta))
  
  #omit first pc to adjust
  allvar_PC_adjust <- allvar_PC[,2:ncol(allvar_PC)]
  
  ### Clean all variable PCs for plotting ###
  
  #plot number of PCs specified by user 
  #reduces number of columns to be equal to "num"
  plotting_PCs <- allvar_PC_adjust[,1:Num]
  
  #convert plotting PCs to numeric
  plotting_PCs_num <- apply(plotting_PCs,2, as.numeric)
  
  #convert plotting PCs to dataframe
  plotting_PCs_num <- as.data.frame(plotting_PCs_num)
  
  #Rename columna to PC 1, 2, 3, etc...
  colnames(plotting_PCs_num) <- sapply(1:Num, function(x) paste("PC",x, sep=""))
  
  #Rename rownames accordiong to variable names (metadata)
  plotting_PCs_num$meta <- rownames(plotting_PCs[1:nrow(plotting_PCs),])
  
  #Melt dataframe to long format for plotting
  plotting_PCs_melt <- reshape2::melt(plotting_PCs_num, id.vars="meta")
  
  #Cluster metadata according to order specified by user
  ord <- Order
  plotting_PCs_order <- unique(plotting_PCs_melt$meta)[rev(ord)]
  plotting_PCs_melt$meta <- factor(plotting_PCs_melt$meta, levels = plotting_PCs_order)
  
  #hard code colours for heat map into dataframe according to PC significance
  plotting_PCs_melt$Pvalue<-sapply(1:nrow(plotting_PCs_melt), function(x)
    if(plotting_PCs_melt$value[x]<=0.001){"<=0.001"}else{
      if(plotting_PCs_melt$value[x]<=0.01){"<=0.01"}else{
        if(plotting_PCs_melt$value[x]<=0.05){"<=0.05"}else{">0.05"}}})
  
  heat <- ggplot(plotting_PCs_melt, aes(variable, meta, fill = Pvalue)) +
    geom_tile(color = "black",size=0.5) +
    theme_gray(8) + 
    scale_fill_manual(breaks = c("<=0.001", "<=0.01", "<=0.05", ">0.05"),
                        values=c("#084594","#4292c6","#9ecae1","#ffffff")) + 
    theme(axis.text = element_text(size =10, color="black"),
          axis.text.x = element_text(),
          axis.title = element_text(size =15),
          legend.text = element_text(size =14),
          legend.title = element_text(size =12),
          legend.position = "bottom",
          plot.margin=unit(c(0,2.25,1,1),"cm"))+
    xlab("Principal Component")+ylab(NULL)
  
  cowplot::plot_grid(scree, heat, ncol=1)
}

```


```{r model_matrix_age1}

#change categorical variables to factors
y1_pdata_sub$Run_y1 <- as.factor(y1_pdata_sub$Run)
y1_pdata_sub$Chip_y1 <- as.factor(y1_pdata_sub$Sentrix_ID)
#pull out row from sentrix position then set to factor
y1_pdata_sub$Row_y1 <- substr(y1_pdata_sub$Sentrix_Position, 1, 3)
y1_pdata_sub$Row_y1 <- as.factor(y1_pdata_sub$Row_y1)
y1_pdata_sub$Row_y1 <- as.numeric(y1_pdata_sub$Row_y1)
y1_pdata_sub$Sex <- as.factor(y1_pdata_sub$Sex)
y1_pdata_sub$Group <- as.factor(y1_pdata_sub$Group)
y1_pdata_sub$Atopy <- as.factor(y1_pdata_sub$Atopy)
y1_pdata_sub$Wheeze <- as.factor(y1_pdata_sub$Wheeze)

y1_pdata_sub$Chip_cb <- as.factor(cb_pdata$Sentrix_ID)
y1_pdata_sub$Row_cb <- substr(cb_pdata$Sentrix_Position, 1, 3)
y1_pdata_sub$Row_cb <- as.factor(y1_pdata_sub$Row_cb)
y1_pdata_sub$Row_cb <- as.numeric(y1_pdata_sub$Row_cb)
y1_pdata_sub$Run_cb <- as.factor(cb_pdata$Run)



#check to see if samples are in same order between pData and and betas
identical(as.character(y1_pdata_sub$Sample_Label), rownames(ccc))
#bind columns together for one large metadata frame
y1_pdata_sub <- cbind(y1_pdata_sub, ccc)


#create a model matrix using pData
#this generates intercepts only since we are not adding in covariates
mod = model.matrix(~1, data=y1_pdata_sub)
```


```{r heatscree_before}
#convert raw betas to mvals
diff_mvals <- lumi::beta2m(diff_betas)
max(diff_mvals)
min(diff_mvals)

#pca 
uncor.dat <- t(scale(t(diff_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T",
                                   "cb.CD4T","y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```

```{r heatscree_celltype}
#pca 
uncor.dat <- t(scale(t(celltype_adj_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


```{r heatscree_9celltypes}
#pca 
uncor.dat <- t(scale(t(celltype9_adj_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]
# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


```{r heatscree_11PCs}
#pca 
uncor.dat <- t(scale(t(adj_pc11_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


```{r heatscree_10PCs}
#pca 
uncor.dat <- t(scale(t(adj_pc10_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]
# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


```{r heatscree_9PCs}
#pca 
uncor.dat <- t(scale(t(adj_pc9_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)

#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]

# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```


```{r heatscree_8PCs}
#pca 
uncor.dat <- t(scale(t(adj_pc8_mvals)))
PCA_full<-princomp(na.omit(uncor.dat))
Loadings<-as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <-vars/sum(vars)


#Specify which covariates are categorical and/or continuous
meta_categorical <- y1_pdata_sub[,c("Sex", "Group", "Run_y1", "Chip_y1",  "Run_cb", "Chip_cb")] 
meta_continuous <- y1_pdata_sub[,c("cb.nRBC" ,"cb.NK", "cb.Bcell", "cb.Mono", "cb.CD8T", "cb.CD4T",
                               "y1.NK", "y1.Bcell", "y1.Mono", "y1.CD8T", "y1.CD4T",
                               "Row_y1", "Row_cb")]
# Specify the number of PCs you want shown 
# pick enough to view most of the variance
Num<-10

# Designate what order you want the variables to appear (continuous variables rbinded to categorical variables in function)
Order<-c(1:19)

#Apply function on PCA results of uncorrected data, pulls in the meta data and beta values from above
heat_scree_plot(Loadings, Importance, Num, Order)
```

